<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dll injection | Aaron Klotz at Mozilla]]></title>
  <link href="http://dblohm7.ca/blog/categories/dll-injection/atom.xml" rel="self"/>
  <link href="http://dblohm7.ca/"/>
  <updated>2019-01-23T18:45:28-07:00</updated>
  <id>http://dblohm7.ca/</id>
  <author>
    <name><![CDATA[Aaron Klotz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2018 Roundup: Q2, Part 1]]></title>
    <link href="http://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/"/>
    <updated>2019-01-23T18:30:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1</id>
    <content type="html"><![CDATA[<p><em>This is the second post in my &ldquo;2018 Roundup&rdquo; series. For an index of all entries, please see my
blog entry for <a href="http://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Q1</a>.</em></p>

<h2>Refactoring the DLL Interceptor</h2>

<p>As I have alluded to <a href="http://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time/">previously</a>,
Gecko includes a Detours-style API hooking mechanism for Windows. In Gecko, this code is referred to
as the &ldquo;DLL Interceptor.&rdquo; We use the DLL interceptor to instrument various functions within our own
processes. As a prerequisite for future DLL injection mitigations, I needed to spend a good chunk of
Q2 refactoring this code. While I was in there, I took the opportunity to improve the interceptor&rsquo;s
memory efficiency, thus benefitting the Fission MemShrink project. [<em>When these changes landed, we were
not yet tracking the memory savings, but I will include a rough estimate <a href="#vmsharing">later</a> in this post.</em>]</p>

<h3>A Brief Overview of Detours-style API Hooking</h3>

<p>While many distinct function hooking techniques are used in the Windows ecosystem, the Detours-style
hook is one of the most effective and most popular. While I am not going to go into too many specifics
here, I&rsquo;d like to offer a quick overview. In this description, &ldquo;target&rdquo; is the function being hooked.</p>

<p>Here is what happens when a function is detoured:</p>

<ol>
<li><p>Allocate a chunk of memory to serve as a &ldquo;trampoline.&rdquo; We must be able to adjust the protection
attributes on that memory.</p></li>
<li><p>Disassemble enough of the target to make room for a <code>jmp</code> instruction. On 32-bit x86 processors,
this requires 5 bytes. x86-64 is more complicated, but generally, to <code>jmp</code> to an absolute address, we
try to make room for 13 bytes.</p></li>
<li><p>Copy the instructions from step 2 over to the trampoline.</p></li>
<li><p>At the beginning of the target function, write a <code>jmp</code> to the hook function.</p></li>
<li><p>Append additional instructions to the trampoline that, when executed, will cause the processor to
jump back to the first valid instruction after the <code>jmp</code> written in step 4.</p></li>
<li><p>If the hook function wants to pass control on to the original target function, it calls the
trampoline.</p></li>
</ol>


<p>Note that these steps don&rsquo;t occur <em>exactly</em> in the order specified above; I selected the above ordering
in an effort to simplify my description.</p>

<p>Here is an attempt at visualizing the control flow of a detoured function on x86-64:</p>

<p><img class="<a" src="href="http://dblohm7.ca/images/detours_hook.svg">http://dblohm7.ca/images/detours_hook.svg</a>&#8221;></p>

<h3>Refactoring</h3>

<p>Previously, the DLL interceptor relied on directly manipulating pointers in order to read and write the
various instructions involved in the hook. In <a title="Parameterize memory operations in WindowsDllInterceptor" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1432653">bug 1432653</a> I changed things so that the memory
operations are parameterized based on two orthogonal concepts:</p>

<ul>
<li>In-process vs out-of-process memory access: I wanted to be able to abstract reads and writes such
that we could optionally set a hook in another process from our own.</li>
<li>Virtual memory allocation scheme: I wanted to be able to change how trampoline memory was allocated.
Previously, each instance of <code>WindowsDllInterceptor</code> allocated its own page of memory for trampolines,
but each instance also typically only sets one or two hooks. This means that most of the 4KiB page
was unused. Furthermore, since Windows allocates blocks of pages on a 64KiB boundary, this wasted a
lot of precious virtual address space in our 32-bit builds.</li>
</ul>


<p>By refactoring and parameterizing these opeations, we ended up with the following combinations:</p>

<ul>
<li>In-process memory access, each <code>WindowsDllInterceptor</code> instance receives its own trampoline space;</li>
<li>In-process memory access, all <code>WindowsDllInterceptor</code> instances within a module <em>share</em> trampoline space;</li>
<li>Out-of-process memory access, each <code>WindowsDllInterceptor</code> instance receives its own trampoline space;</li>
<li>Out-of-process memory access, all <code>WindowsDllInterceptor</code> instances within a module share trampoline space (currently
not implemented as this option is not particularly useful at the moment).</li>
</ul>


<p>Instead of directly manipulating pointers, we now use instances of <code>ReadOnlyTargetFunction</code>,
<code>WritableTargetFunction</code>, and <code>Trampoline</code> to manipulate our code/data. Those classes in turn use the
memory management and virtual memory allocation policies to perform the actual reading and writing.</p>

<h3>Memory Management Policies</h3>

<p>The interceptor now supports two policies, <code>MMPolicyInProcess</code> and <code>MMPolicyOutOfProcess</code>. Each policy
must implement the following memory operations:</p>

<ul>
<li>Read</li>
<li>Write</li>
<li>Change protection attributes</li>
<li>Reserve trampoline space</li>
<li>Commit trampoline space</li>
</ul>


<p><code>MMPolicyInProcess</code> is implemented using <code>memcpy</code> for read and write, <code>VirtualProtect</code>
for protection attribute changes, and <code>VirtualAlloc</code> for reserving and committing trampoline space.</p>

<p><code>MMPolicyOutOfProcess</code> uses <code>ReadProcessMemory</code> and <code>WriteProcessMemory</code> for read and write. As a perf
optimization, we try to batch reads and writes together to reduce the system call traffic. We obviously
use <code>VirtualProtectEx</code> to adjust protection attributes in the other process.</p>

<p>Out-of-process trampoline reservation and commitment, however, is a bit different and is worth a
separate call-out. We allocate trampoline space using shared memory. It is mapped into the local
process with read+write permissions using <code>MapViewOfFile</code>. The memory is mapped into the remote process
using some code that I wrote in <a title="Add out-of-process memory access policies to DLL interceptor" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1451511">bug 1451511</a> that either uses <code>NtMapViewOfSection</code> or
<code>MapViewOfFile2</code>, depending on availability. Individual pages from those chunks are then committed via
<code>VirtualAlloc</code> in the local process and <code>VirtualAllocEx</code> in the remote process. This scheme enables
us to read and write to trampoline memory directly, without needing to do cross-process reads and writes!</p>

<h3>VM Sharing Policies</h3>

<p>The code for these policies is a lot simpler than the code for the memory management policies. We now
have <code>VMSharingPolicyUnique</code> and <code>VMSharingPolicyShared</code>. Each of these policies must implement the
following operations:</p>

<ul>
<li>Reserve space for up to <em>N</em> trampolines of size <em>K</em>;</li>
<li>Obtain a <code>Trampoline</code> object for the next available <em>K</em>-byte trampoline slot;</li>
<li>Return an iterable collection of all extant trampolines.</li>
</ul>


<p><code>VMSharingPolicyShared</code> is actually implemented by delegating to a <code>static</code> instance of
<code>VMSharingPolicyUnique</code></p>

<h3>Implications of Refactoring</h3>

<p>To determine the performance implications, I added timings to our DLL Interceptor unit test. I was
very happy to see that, despite the additional layers of abstraction, the C++ compiler&rsquo;s optimizer is
doing its job: There was no performance impact whatsoever!</p>

<p><a name="vmsharing"></a>Once the refactoring was complete, I switched the default VM Sharing Policy for <code>WindowsDllInterceptor</code>
over to <code>VMSharingPolicyShared</code> in <a title="DLL interceptors should share trampoline VM" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1451524">bug 1451524</a>.</p>

<p>Browsing today&rsquo;s <code>mozilla-central</code> tip, I count 14 locations where we instantiate interceptors inside
<code>xul.dll</code>. Given that not all interceptors are necessarily instantiated at once, I am now offering a
worst-case back-of-the-napkin estimate of the memory savings:</p>

<ul>
<li>Each interceptor would likely be consuming 4KiB (most of which is unused) of committed VM. Due to
Windows&#8217; 64 KiB allocation guanularity, each interceptor would be leaving a further 60KiB
of address space in a free but unusable state. Assuming all 14 interceptors were actually instantiated,
they would thus consume a combined 56KiB of committed VM and 840KiB of free but unusable address space.</li>
<li>By sharing trampoline VM, the interceptors would consume only 4KiB combined and waste only 60KiB of
address space, thus yielding savings of 52KiB in committed memory and 780KiB in addressable memory.</li>
</ul>


<h3>Oh, and One More Thing</h3>

<p>Another problem that I discovered during this refactoring was <a title="Repeated failed function hook attempts cause exhaustion of interceptor trampoline space" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1459335">bug 1459335</a>. It turns out that the
interceptor&rsquo;s callers were not distinguishing between &ldquo;I have not set this hook yet&rdquo; and &ldquo;I attempted
to set this hook but it failed.&rdquo; Across several call sites, I discovered that our code would repeatedly
retry to set hooks even when they had previously failed, causing leakage of trampoline space!</p>

<p>To fix this, I modified the interceptor&rsquo;s interface so that we use one-time initialization APIs to
set hooks; since landing this bug, it is no longer possible for clients of the DLL interceptor to
set a hook that had previously failed to be set.</p>

<p>Quantifying the memory costs of this bug is&hellip; non-trivial, but it suffices to say that fixing
this bug probably resulted in the savings of at least a few hundred KiB in committed VM.</p>

<p>That&rsquo;s it for today&rsquo;s post, folks! Thanks for reading! Coming up in Q2, Part 2: Implementing a Skeletal Launcher Process</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018 Roundup: Q1]]></title>
    <link href="http://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/"/>
    <updated>2019-01-18T17:30:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2019/01/18/2018-roundup-q1</id>
    <content type="html"><![CDATA[<p>I had a very busy 2018. So busy, in fact, that I have not been able to devote any time to actually
discussing what I worked on! I had intended to write these posts during the end of December, but a
hardware failure delayed that until the new year. Alas, here we are in 2019, and I am going to do a
series of retrospectives on last year&rsquo;s work, broken up by quarter.</p>

<p>Here is an index of the remaining entries in this series:</p>

<ul>
<li><a href="http://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">2018 Roundup: Q2, Part 1</a></li>
</ul>


<h2>Overview</h2>

<p>The general theme of my work in 2018 was dealing with the DLL injection problem: On Windows,
third parties love to forcibly load their DLLs into other processes &ndash; web browsers in particular,
thus making Firefox a primary target.</p>

<p>Many of these libraries tend to alter Firefox processes in ways that hurt the stability and/or performance
of our code; many chemspill releases have gone out over the years to deal with these problems. While I
could rant for hours over this, the fact is that DLL injection is rampant in the ecosystem of Windows
desktop applications and is not going to disappear any time soon. In the meantime, we need to be able
to deal with it.</p>

<p>Some astute readers might be ready to send me an email or post a comment about how ignorant I am about
the new(-ish) process mitigation policies that are available in newer versions of Windows. While those
features are definitely useful, they are not panaceas:</p>

<ul>
<li>We cannot turn on the &ldquo;Extension Point Disable&rdquo; policy for users of assistive technologies; screen
readers rely heavily on DLL injection using <code>SetWindowsHookEx</code> and <code>SetWinEventHook</code>, both of which
are covered by this policy;</li>
<li>We could enable the &ldquo;Microsoft Binary Signature&rdquo; policy, however that requires us to load our own
DLLs first before enabling; once that happens, it is often already too late: other DLLs have already
injected themselves by the time we are able to activate this policy. (Note that this could easily be
solved if this policy were augmented to also permit loading of any DLL signed by the same organization
as that of the process&rsquo;s executable binary, but Microsoft seems to be unwilling to do this.)</li>
<li>The above mitigations are not universally available. They do not help us on Windows 7.</li>
</ul>


<p>For me, Q1 2018 was all about gathering better data about injected DLLs.</p>

<h2>Learning More About DLLs Injected into Firefox</h2>

<p>One of our major pain points over the years of dealing with injected DLLs has been that the vendor of
the DLL is not always apparent to us. In general, our crash reports and telemetry pings only include
the leaf name of the various DLLs on a user&rsquo;s system. This is intentional on our part: we want to
preserve user privacy. On the other hand, this severely limits our ability to determine which party
is responsible for a particular DLL.</p>

<p>One avenue for obtaining this information is to look at any digital signature that is embedded in the
DLL. By examining the certificate that was used to sign the binary, we can extract the organization
of the cert&rsquo;s owner and include that with our crash reports and telemetry.</p>

<p>In <a title="Include authenticode cert information with crash reports" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1430857">bug 1430857</a> I wrote a bunch of code that enables us to extract that information from signed
binaries using the Windows Authenticode APIs. Originally, in that bug, all of that signature extraction
work happened from within the browser itself, while it was running: It would gather the cert information
on a background thread while the browser was running, and include those annotations in a subsequent
crash dump, should such a thing occur.</p>

<p>After some reflection, I realized that I was not gathering annotations in the right place. As an example,
what if an injected DLL were to trigger a crash before the background thread had a chance to grab
that DLL&rsquo;s cert information?</p>

<p>I realized that the best place to gather this information was in a post-processing step after the
crash dump had been generated, and in fact we already had the right mechanism for doing so: the
<code>minidump-analyzer</code> program was already doing post-processing on Firefox crash dumps before sending
them back to Mozilla. I moved the signature extraction and crash annotation code out of Gecko and
into the analyzer in <a title="Cert annotation performance and reliability improvements" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1436845">bug 1436845</a>.</p>

<p>(As an aside, while working on the <code>minidump-analyzer</code>, I found some problems with how it handled
command line arguments: it was assuming that <code>main</code> passes its <code>argv</code> as UTF-8, which is not true on
Windows. I fixed those issues in <a title="Minidump analyzer assuming utf-8 command-line arguments on Windows" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1437156">bug 1437156</a>.)</p>

<p>In <a title="Add module cert info to modules ping" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1434489">bug 1434489</a> I also ended up adding this information to the &ldquo;modules ping&rdquo; that we have in
telemetry; IIRC this ping is only sent weekly. When the modules ping is requested, we gather the
module cert info asynchronously on a background thread.</p>

<p>Finally, I had to modify Socorro (the back-end for <a href="https://crash-stats.mozilla.com">crash-stats</a>) to
be able to understand the signature annotations and be able to display them via <a title="Add module cert info to crash report "Modules" tab" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1434495">bug 1434495</a>. This
required two commits: one to modify the Socorro stackwalker to merge the module signature information
into the full crash report, and another to add a &ldquo;Signed By&rdquo; column to every report&rsquo;s &ldquo;Modules&rdquo; tab to
display the signature information (Note that this column is only present when at least one module in
a particular crash report contains signature information).</p>

<p>The end result was very satisfying: Most of the injected DLLs in our Windows crash reports are signed,
so it is now much easier to identify their vendors!</p>

<p>This project was very satisifying for me in many ways: First of all, surfacing this information was an
itch that I had been wanting to scratch for quite some time. Secondly, this really was a &ldquo;full stack&rdquo;
project, touching everything from extracting signature info from binaries using C++, all the way up to
writing some back-end code in Python and a little touch of front-end stuff to surface the data in the
web app.</p>

<p>Note that, while this project focused on Windows because of the severity of the library injection
problem on that platform, it would be easy enough to reuse most of this code for macOS builds as well;
the only major work for the latter case would be for extracting signature information from a dylib.
This is not currently a priority for us, though.</p>

<p>Thanks for reading! Coming up in <a href="http://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">Q2</a>:
Refactoring the DLL Interceptor!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs from Hell: Injected Third-party Code + Detours = A Bad Time]]></title>
    <link href="http://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time/"/>
    <updated>2016-01-11T13:00:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time</id>
    <content type="html"><![CDATA[<p>Happy New Year!</p>

<p>I&rsquo;m finally getting &lsquo;round to writing about a nasty bug that I had to spend a
bunch of time with in Q4 2015. It&rsquo;s one of the more challenging problems that
I&rsquo;ve had to break and I&rsquo;ve been asked a lot of questions about it. I&rsquo;m talking
about <a title="Crash spike in CreateWindowEx with Firefox 42.0b9 on Optimus" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473">bug 1218473</a>.</p>

<h2>How This All Began</h2>

<p>In <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a> I had landed a patch to intercept calls to <code>CreateWindowEx</code>.
This was necessary because it was apparent in that bug that window subclassing
was occurring while a window was neutered (&ldquo;neutering&rdquo; is terminology that is
specific to Mozilla&rsquo;s Win32 IPC code).</p>

<p>While I&rsquo;ll save a discussion on the specifics of window neutering for another
day, for our purposes it is sufficient for me to point out that subclassing a
neutered window is bad because it creates an infinite recursion scenario with
window procedures that will eventually overflow the stack.</p>

<p>Neutering is triggered during certain types of IPC calls as soon as a message is
sent to an unneutered window on the thread making the IPC call. Unfortunately in
the case of <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, the message triggering the neutering was
<code>WM_CREATE</code>. Shortly after creating that window, the code responsible would
subclass said window. Since <code>WM_CREATE</code> had already triggered neutering, this
would result in the pathological case that triggers the stack overflow.</p>

<p>For a fix, what I wanted to do is to prevent messages that were sent immediately
during the execution of <code>CreateWindow</code> (such as <code>WM_CREATE</code>) from triggering
neutering prematurely. By intercepting calls to <code>CreateWindowEx</code>, I could wrap
those calls with a RAII object that temporarily suppresses the neutering. Since
the subclassing occurs immediately after window creation, this meant that
this subclassing operation was now safe.</p>

<p>Unfortunately, shortly after landing <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, <a title="Crash spike in CreateWindowEx with Firefox 42.0b9 on Optimus" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473">bug 1218473</a> was filed.</p>

<h2>Where to Start</h2>

<p>It wasn&rsquo;t obvious where to start debugging this. While a crash spike was clearly
correlated with the landing of <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, the crashes were occurring in
code that had nothing to do with IPC or Win32. For example, the first stack that
I looked at was <code>js::CreateRegExpMatchResult</code>!</p>

<p>When it is just not clear where to begin, I like to start by looking at our
correlation data in Socorro &ndash; you&rsquo;d be surprised how often they can bring
problems into sharp relief!</p>

<p>In this case, the correlation data didn&rsquo;t disappoint: there
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473#c10">was</a> 100% correlation
with a module called <code>_etoured.dll</code>. There was also correlation with the
presence of both NVIDIA video drivers <em>and</em> Intel video drivers. Clearly this
was a concern only when NVIDIA Optimus technology was enabled.</p>

<p>I also had a pretty strong hypothesis about what <code>_etoured.dll</code> was: For many
years, Microsoft Research has shipped a package called
<a href="http://research.microsoft.com/en-us/projects/detours/">Detours</a>. Detours is a
library that is used for intercepting Win32 API calls. While the changelog for
Detours 3.0 points out that it has &ldquo;Removed [the] requirement for including
<code>detoured.dll</code> in processes,&rdquo; in previous versions of the package, this library
was required to be injected into the target process.</p>

<p>I concluded that <code>_etoured.dll</code> was most likely a renamed version of
<code>detoured.dll</code> from Detours 2.x.</p>

<h2>Following The Trail</h2>

<p>Now that I knew the likely culprit, I needed to know how it was getting there.
During a November trip to the Mozilla Toronto office, I spent some time
debugging a test laptop that was configured with Optimus.</p>

<p>Knowing that the presence of Detours was somehow interfering with our own API
interception, I decided to find out whether it was also trying to intercept
<code>CreateWindowExW</code>. I launched <code>windbg</code>, started Firefox with it, and then told
it to break as soon as <code>user32.dll</code> was loaded:</p>

<pre><samp>
sxe ld:user32.dll
</samp></pre>


<p>Then I pressed <code>F5</code> to resume execution. When the debugger broke again, this
time <code>user32</code> was now in memory. I wanted the debugger to break as soon as
<code>CreateWindowExW</code> was touched:</p>

<pre><samp>
ba w 4 user32!CreateWindowExW
</samp></pre>


<p>Once again I resumed execution. Then the debugger broke on the memory access and
gave me this call stack:</p>

<pre><samp>
nvd3d9wrap!setDeviceHandle+0x1c91
nvd3d9wrap!initialise+0x373
nvd3d9wrap!setDeviceHandle+0x467b
nvd3d9wrap!setDeviceHandle+0x4602
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
KERNELBASE!LoadLibraryExA+0x26
kernel32!LoadLibraryA+0xba
nvinit+0x11cb
nvinit+0x5477
nvinit!nvCoprocThunk+0x6e94
nvinit!nvCoprocThunk+0x6e1a
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
kernel32!BasepLoadAppInitDlls+0x167
kernel32!LoadAppInitDlls+0x82
USER32!ClientThreadSetup+0x1f9
USER32!__ClientThreadSetup+0x5
ntdll!KiUserCallbackDispatcher+0x2e
GDI32!GdiDllInitialize+0x1c
USER32!_UserClientDllInitialize+0x32f
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
firefox!XPCOMGlueLoad+0x23c
firefox!XPCOMGlueStartup+0x1d
firefox!InitXPCOMGlue+0xba
firefox!NS_internal_main+0x5c
firefox!wmain+0xbe
firefox!__tmainCRTStartup+0xfe
kernel32!BaseThreadInitThunk+0xe
ntdll!__RtlUserThreadStart+0x70
ntdll!_RtlUserThreadStart+0x1b
</samp></pre>


<p>This stack is a gold mine of information. In particular, it tells us the
following:</p>

<ol>
<li><p>The offending DLLs are being injected by <code>AppInit_DLLs</code> (and in fact, Raymond
Chen <a href="https://blogs.msdn.microsoft.com/oldnewthing/20140422-00/?p=1173">has blogged about</a>
this exact case in the past).</p></li>
<li><p><code>nvinit.dll</code> is the name of the DLL that is injected by step 1.</p></li>
<li><p><code>nvinit.dll</code> loads <code>nvd3d9wrap.dll</code> which then uses Detours to patch
our copy of <code>CreateWindowExW</code>.</p></li>
</ol>


<p>I then became curious as to which other functions they were patching.</p>

<p>Since Detours is patching executable code, we know that at some point it is
going to need to call <code>VirtualProtect</code> to make the target code writable. In the
worst case, <code>VirtualProtect</code>&rsquo;s caller is going to pass the address of the page
where the target code resides. In the best case, the caller will pass in the
address of the target function itself!</p>

<p>I restarted <code>windbg</code>, but this time I set a breakpoint on <code>VirtualProtect</code>:</p>

<pre><samp>
bp kernel32!VirtualProtect
</samp></pre>


<p>I then resumed the debugger and examined the call stack every time it broke.
While not every single <code>VirtualProtect</code> call would correspond to a detour, it
would be obvious when it was, as the NVIDIA DLLs would be on the call stack.</p>

<p>The first time I caught a detour, I examined the address being passed to
<code>VirtualProtect</code>: I ended up with the best possible case: the address was
pointing to the actual target function! From there I was able to distill a
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473#c39">list</a> of other
functions being hooked by the injected NVIDIA DLLs.</p>

<h2>Putting it all Together</h2>

<p>By this point I knew who was hooking our code and knew how it was getting there.
I also noticed that <code>CreateWindowEx</code> is the only function that the NVIDIA DLLs
and our own code were both trying to intercept. Clearly there was some kind of
bad interaction occurring between the two interception mechanisms, but what was
it?</p>

<p>I decided to go back and examine a
<a href="https://crash-stats.mozilla.com/report/index/e884dc17-957f-4270-86ab-f59742151113">specific</a>
crash dump. In particular, I wanted to examine three different memory locations:</p>

<ol>
<li>The first few instructions of <code>user32!CreateWindowExW</code>;</li>
<li>The first few instructions of <code>xul!CreateWindowExWHook</code>; and</li>
<li>The site of the call to <code>user32!CreateWindowExW</code> that triggered the crash.</li>
</ol>


<p>Of those three locations, the only one that looked off was location 2:</p>

<pre><samp>
6b1f6611 56              push    esi
6b1f6612 ff15f033e975    call    dword ptr [combase!CClassCache::CLSvrClassEntry::GetDDEInfo+0x41 (75e933f0)]
6b1f6618 c3              ret
6b1f6619 7106            jno     xul!`anonymous namespace'::CreateWindowExWHook+0x6 (6b1f6621)
xul!`anonymous namespace'::CreateWindowExWHook:
6b1f661b cc              int     3
6b1f661c cc              int     3
6b1f661d cc              int     3
6b1f661e cc              int     3
6b1f661f cc              int     3
6b1f6620 cc              int     3
6b1f6621 ff              ???
</samp></pre>


<p><em>Why the hell were the first six bytes filled with breakpoint instructions?</em></p>

<p>I decided at this point to look at some source code. Fortunately Microsoft
publishes the 32-bit source code for Detours, licensed for non-profit use,
under the name &ldquo;Detours Express.&rdquo;</p>

<p>I found a copy of Detours Express 2.1 and checked out the code. First I wanted
to know where all of these <code>0xcc</code> bytes were coming from. A quick <code>grep</code> turned
up what I was looking for:</p>

<pre><code class="c++ detours.cpp start:93">inline PBYTE detour_gen_brk(PBYTE pbCode, PBYTE pbLimit)
{
    while (pbCode &lt; pbLimit) {
        *pbCode++ = 0xcc;   // brk;
    }
    return pbCode;
}
</code></pre>

<p>Now that I knew which function was generating the <code>int 3</code> instructions, I then
wanted to find its callers. Soon I found:</p>

<pre><code class="c++ detours.cpp start:1247">#ifdef DETOURS_X86
    pbSrc = detour_gen_jmp_immediate(pTrampoline-&gt;rbCode + cbTarget, pTrampoline-&gt;pbRemain);
    pbSrc = detour_gen_brk(pbSrc,
                           pTrampoline-&gt;rbCode + sizeof(pTrampoline-&gt;rbCode));
#endif // DETOURS_X86
</code></pre>

<p>Okay, so Detours writes the breakpoints out immediately after it has written a
<code>jmp</code> pointing to its trampoline.</p>

<p><em>Why is our hook function being trampolined?</em></p>

<p>The reason must be because our hook was installed first! Detours has
detected that and has decided that the best place to trampoline to the NVIDIA
hook is at the beginning of our hook function.</p>

<p><em>But Detours is using the wrong address!</em></p>

<p>We can see that because the <code>int 3</code> instructions are written out at the
<em>beginning</em> of <code>CreateWindowExWHook</code>, even though there should be a <code>jmp</code>
instruction first.</p>

<p><strong>Detours is calculating the wrong address to write its <code>jmp</code>!</strong></p>

<h2>Finding a Workaround</h2>

<p>Once I knew <em>what</em> the problem was, I needed to know more about the <em>why</em> &ndash;
only then would I be able to come up with a way to work around this problem.</p>

<p>I decided to reconstruct the scenario where both our code and Detours are trying
to hook the same function, but our hook was installed first. I would then
follow along through the Detours code to determine how it calculated the wrong
address to install its <code>jmp</code>.</p>

<p>The first thing to keep in mind is that Mozilla&rsquo;s function interception code
takes advantage of <a href="https://blogs.msdn.microsoft.com/oldnewthing/20110921-00/?p=9583">hot-patch points</a>
in Windows. If the target function begins with a <code>mov edi, edi</code> prolog, we
use a hot-patch style hook instead of a trampoline hook. I am not going to go
into detail about hot-patch hooks here &ndash; the above Raymond Chen link contains
enough details to answer your questions. For the purposes of this blog post, the
important point is that Mozilla&rsquo;s code patches the <code>mov edi, edi</code>, so NVIDIA&rsquo;s
Detours library would need to recognize and follow the <code>jmp</code>s that our code
patched in, in order to write its own <code>jmp</code> at <code>CreateWindowExWHook</code>.</p>

<p>Tracing through the Detours code, I found the place where it checks for a
hot-patch hook and follows the <code>jmp</code> if necessary. While examining a function
called <code>detour_skip_jmp</code>, I found the bug:</p>

<pre><code class="c++ detours.cpp start:124">            pbNew = pbCode + *(INT32 *)&amp;pbCode[1];
</code></pre>

<p>This code is supposed to be telling Detours where the target address of a <code>jmp</code>
is, so that Detours can follow it. <code>pbNew</code> is supposed to be the target address
of the <code>jmp</code>. <code>pbCode</code> is referencing the address <em>of the beginning of the <code>jmp</code>
instruction itself</em>. Unfortunately, with this type of <code>jmp</code> instruction, target
addresses are always relative to the address of the <em>next</em> instruction, not
the <em>current</em> instruction! Since the current <code>jmp</code> instruction is five bytes
long, Detours ends up writing its <code>jmp</code> <em>five bytes prior</em> to the intended
target address!</p>

<p>I went and checked the source code for Detours Express 3.0 to see if this had
been fixed, and indeed it had:</p>

<pre><code class="c++ detours.cpp start:163">            PBYTE pbNew = pbCode + 5 + *(INT32 *)&amp;pbCode[1];
</code></pre>

<p>That doesn&rsquo;t do much for me right now, however, since the NVIDIA stuff is still
using Detours 2.x.</p>

<p>In the case of Mozilla&rsquo;s code, there is legitimate executable code at that
incorrect address that Detours writes to. It is corrupting the last few
instructions of that function, thus explaining those mysterious crashes that
were seemingly unrelated code.</p>

<p>I confirmed this by downloading the binaries from the build that was associated
with the crash dump that I was analyzing. [As an aside, I should point out that
you need to grab the <em>identical</em> binaries for this exercise; you cannot build
from the same source revision and expect this to work due to variability that
is introduced into builds by things like PGO.]</p>

<p>The five bytes preceeding <code>CreateWindowExHookW</code> in the crash dump diverged from
those same bytes in the original binaries. I could also make out that the
overwritten bytes consisted of a <code>jmp</code> instruction.</p>

<h3>In Summary</h3>

<p>Let us now review what we know at this point:</p>

<ul>
<li>Detours 2.x doesn&rsquo;t correctly follow <code>jmp</code>s from hot-patch hooks;</li>
<li>If Detours tries to hook something that has already been hot-patched
(including legitimate hot patches from Microsoft), it will write bytes at
incorrect addresses;</li>
<li>NVIDIA Optimus injects this buggy code into everybody&rsquo;s address spaces via an
<code>AppInit_DLLs</code> entry for <code>nvinit.dll</code>.</li>
</ul>


<p>How can we best distill this into a suitable workaround?</p>

<p>One option could be to block the NVIDIA DLLs outright. In most cases this would
probably be the simplest option, but I was hesitant to do so this time. I was
concerned about the unintended consequences of blocking what, for better or
worse, is a user-mode component of NVIDIA video drivers.</p>

<p>Instead I decided to take advantage of the fact that we now know how this bug is
triggered. I have modified our API interception code such that if it detects
the presence of NVIDIA Optimus, it disables hot-patch style hooks.</p>

<p>Not only will this take care of the crash spike that started when I landed
<a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, I also expect it to take care of other crash signatures
whose relationship to this bug was not obvious.</p>

<p>That concludes this episode of <em>Bugs from Hell</em>. Until next time&hellip;</p>
]]></content>
  </entry>
  
</feed>
