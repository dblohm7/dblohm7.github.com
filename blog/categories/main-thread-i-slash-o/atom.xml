<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: main thread i/o | Aaron Klotz's Software Blog]]></title>
  <link href="https://dblohm7.ca/blog/categories/main-thread-i-slash-o/atom.xml" rel="self"/>
  <link href="https://dblohm7.ca/"/>
  <updated>2022-02-11T09:51:44-07:00</updated>
  <id>https://dblohm7.ca/</id>
  <author>
    <name><![CDATA[Aaron Klotz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Detecting Main Thread I/O with SPS]]></title>
    <link href="https://dblohm7.ca/blog/2013/06/12/detecting-main-thread-i-slash-o-with-sps/"/>
    <updated>2013-06-12T18:00:00-06:00</updated>
    <id>https://dblohm7.ca/blog/2013/06/12/detecting-main-thread-i-slash-o-with-sps</id>
    <content type="html"><![CDATA[<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=867762">bug 867762</a> I am landing I/O
interpose facilities for SPS. This feature will allow main thread I/O to be
displayed in the profiler UI.</p>

<p>There are a few components to this patch. Classes that implement the
<code>IOInterposerModule</code> interface are responsible for hooking into an arbitrary I/O
facility and calling into <code>IOInterposer</code> with those events.</p>

<p>The <code>IOInterposer</code> receives those events and then dispatches them to any registered
observers. For the purposes of SPS there is only one observer,
<code>ProfilerIOInterposeObserver</code>, however I wrote this keeping in mind that we
may eventually want to use the I/O interpose facilities for other purposes (such
as shutdown write poisioning).</p>

<p>For bug 867762 I have implemented two modules. <code>NSPRInterposer</code> hooks into NSPR
file I/O and generates events whenever a <code>PR_Read</code>, <code>PR_Write</code>, or <code>PR_Sync</code> occurs.
The second module, <code>SQLiteInterposer</code>, leverages the SQLite VFS that we use for
telemetry to tap into reads, writes, and fsyncs generated by SQLite. In the future
we expect to expand this into several additional modules. Some ideas include a module
that uses Event Tracing for Windows to read events from the Windows kernel and a
module that interposes calls to <code>read</code>, <code>write</code>, and <code>fsync</code> on Linux.</p>

<p>On the observer side of things, for now we simply insert a marker into the profiler
timeline whenever main thread I/O is reported. Here is a sample screenshot of the
markers in action (the pink stuff for readers who are unfamiliar with SPS markers):</p>

<p><a href="href="https://dblohm7.ca/images/iomarkers.png">https://dblohm7.ca/images/iomarkers.png</a>&#8221;><img class="<a" src="href="https://dblohm7.ca/images/iomarkers.png">https://dblohm7.ca/images/iomarkers.png</a>&#8221;></a></p>

<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=867757">bug 867757</a> (under review)
this will become more sophisticated, as SPS will immediately sample the callstack of
the thread whose I/O has been intercepted. This annotated stack will be inserted
directly into the timeline.</p>

<p>There will need to be some UI changes for this to be presented in a reasonable way,
but with both existing patches applied the data is already useful. By firing up
Cleopatra and filtering on either <code>NSPRInterposer</code> or <code>SQLiteInterposer</code>, you can
isolate and view the main thread I/O stacks:</p>

<p><a href="href="https://dblohm7.ca/images/iofilteredstacks.png">https://dblohm7.ca/images/iofilteredstacks.png</a>&#8221;><img class="<a" src="href="https://dblohm7.ca/images/iofilteredstacks.png">https://dblohm7.ca/images/iofilteredstacks.png</a>&#8221;></a></p>

<p>Hopefully these patches will prove to be beneficial to our efforts to eliminate
main thread I/O.</p>
]]></content>
  </entry>
  
</feed>
