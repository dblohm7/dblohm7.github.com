<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mozilla | Aaron Klotz at Mozilla]]></title>
  <link href="http://dblohm7.ca/blog/categories/mozilla/atom.xml" rel="self"/>
  <link href="http://dblohm7.ca/"/>
  <updated>2014-06-17T02:31:42-06:00</updated>
  <id>http://dblohm7.ca/</id>
  <author>
    <name><![CDATA[Aaron Klotz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Asynchronous Plugin Initialization: An Introduction]]></title>
    <link href="http://dblohm7.ca/blog/2014/06/17/asynchronous-plugin-initialization-an-introduction/"/>
    <updated>2014-06-17T02:30:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2014/06/17/asynchronous-plugin-initialization-an-introduction</id>
    <content type="html"><![CDATA[<p>I have spent a lot of time this quarter working on <a title="Asynchronous Initialization of Out-of-process Plugins" href="https://bugzilla.mozilla.org/show_bug.cgi?id=998863">bug 998863</a>, &ldquo;Asynchronous
Initialization of Out-of-process Plugins.&rdquo; While the bug summary is fairly self
explanatory, I would like to provide some more details about why I am doing this
and what kind of work it entails. I would also like to wrap up the post with an
early demonstration of this feature and present some profiles to illustrate the
potential performance improvement.</p>

<h2>Rationale</h2>

<p>The reason that I am undertaking this project is because NPAPI plugin startup
is our most frequent cause of jank. In fact, at the time of this writing, our
<a href="http://telemetry.mozilla.org/chromehangs/">Chrome Hangs telemetry</a> is showing
that 4 out of our top 10 most frequent offending call stacks are related to
plugin initialization and instantiation. Furthermore, creating the
plugin-container.exe child process is the #1 most frequent chrome hang offender
(Note that our Chrome Hang telemetry consists entirely of Windows builds, where
process creation is quite expensive).</p>

<h2>A High-level Breakdown of NPAPI Initialization and Instantiation</h2>

<p>The typical steps involved can be broken down as follows:</p>

<ol>
<li>Launch the <code>plugin-container</code> process;</li>
<li>Call <code>NP_Initialize</code> to load the plugin;</li>
<li>Create instances by calling <code>NPP_New</code>;</li>
<li>Call <code>NPP_NewStream</code> for instances that load stream data;</li>
<li>If an instance is scriptable, call <code>NPP_GetValue</code> to obtain information
about the plugin&rsquo;s scriptable object.</li>
</ol>


<p>The patch that I am working on modifies steps 1 through 4 to run asynchronously.
Step 5 is a special case &mdash; we asynchronously return a proxy object, but if a
synchronous JS method is called on that object, we must wait for the plugin to
initialize (if it has not yet done so). My hope is that if we have to call a
synchronous JS method on the proxy object, plugin initialization will be far
enough along that the wait will be minimal.</p>

<h2>A Brief Demonstration</h2>

<p>The following video compares two locally-built Nightlies that are identical
except for the asynchronous initialization patch. After loading the browser
with a page containing several embedded Flash objects, we can profile and
observe the effects of this patch.</p>

<iframe width="420" height="315" src="//www.youtube-nocookie.com/embed/HZ8Z2Drv8uI?rel-0" frameborder="0" allowfullscreen></iframe>


<p>Here are links to some profiles:</p>

<p><a href="http://people.mozilla.org/~bgirard/cleopatra/#report=a5a96119742fa75b64ab7d12566eede68468ef3c">Synchronous Plugin Initialization</a></p>

<p><a href="http://people.mozilla.org/~bgirard/cleopatra/#report=282e372d3357316307c182607f26c00f4f41011e">Asynchronous Plugin Initialization</a></p>

<h2>Disclaimer</h2>

<p>This patch requires some further work on scripting and stabilization. The
information in this post is subject to change. :&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Detecting Main Thread I/O with SPS]]></title>
    <link href="http://dblohm7.ca/blog/2013/06/12/detecting-main-thread-i-slash-o-with-sps/"/>
    <updated>2013-06-12T18:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2013/06/12/detecting-main-thread-i-slash-o-with-sps</id>
    <content type="html"><![CDATA[<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=867762">bug 867762</a> I am landing I/O
interpose facilities for SPS. This feature will allow main thread I/O to be
displayed in the profiler UI.</p>

<p>There are a few components to this patch. Classes that implement the
<code>IOInterposerModule</code> interface are responsible for hooking into an arbitrary I/O
facility and calling into <code>IOInterposer</code> with those events.</p>

<p>The <code>IOInterposer</code> receives those events and then dispatches them to any registered
observers. For the purposes of SPS there is only one observer,
<code>ProfilerIOInterposeObserver</code>, however I wrote this keeping in mind that we
may eventually want to use the I/O interpose facilities for other purposes (such
as shutdown write poisioning).</p>

<p>For bug 867762 I have implemented two modules. <code>NSPRInterposer</code> hooks into NSPR
file I/O and generates events whenever a <code>PR_Read</code>, <code>PR_Write</code>, or <code>PR_Sync</code> occurs.
The second module, <code>SQLiteInterposer</code>, leverages the SQLite VFS that we use for
telemetry to tap into reads, writes, and fsyncs generated by SQLite. In the future
we expect to expand this into several additional modules. Some ideas include a module
that uses Event Tracing for Windows to read events from the Windows kernel and a
module that interposes calls to <code>read</code>, <code>write</code>, and <code>fsync</code> on Linux.</p>

<p>On the observer side of things, for now we simply insert a marker into the profiler
timeline whenever main thread I/O is reported. Here is a sample screenshot of the
markers in action (the pink stuff for readers who are unfamiliar with SPS markers):</p>

<p><a href="href="http://dblohm7.ca/images/iomarkers.png">http://dblohm7.ca/images/iomarkers.png</a>"><img class="<a" src="href="http://dblohm7.ca/images/iomarkers.png">http://dblohm7.ca/images/iomarkers.png</a>"></a></p>

<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=867757">bug 867757</a> (under review)
this will become more sophisticated, as SPS will immediately sample the callstack of
the thread whose I/O has been intercepted. This annotated stack will be inserted
directly into the timeline.</p>

<p>There will need to be some UI changes for this to be presented in a reasonable way,
but with both existing patches applied the data is already useful. By firing up
Cleopatra and filtering on either <code>NSPRInterposer</code> or <code>SQLiteInterposer</code>, you can
isolate and view the main thread I/O stacks:</p>

<p><a href="href="http://dblohm7.ca/images/iofilteredstacks.png">http://dblohm7.ca/images/iofilteredstacks.png</a>"><img class="<a" src="href="http://dblohm7.ca/images/iofilteredstacks.png">http://dblohm7.ca/images/iofilteredstacks.png</a>"></a></p>

<p>Hopefully these patches will prove to be beneficial to our efforts to eliminate
main thread I/O.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plugin Hang UI on Aurora]]></title>
    <link href="http://dblohm7.ca/blog/2013/02/15/plugin-hang-ui-on-aurora/"/>
    <updated>2013-02-15T17:00:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2013/02/15/plugin-hang-ui-on-aurora</id>
    <content type="html"><![CDATA[<h2>The UI Has Landed</h2>

<p>The <a href="http://dblohm7.ca/blog/2012/11/22/plugin-hang-user-interface-for-firefox/">Plugin Hang UI</a>
landed in mozilla-central in time for January&rsquo;s merge. This means that it is
now available on both Nightly and Aurora.</p>

<p>While it&rsquo;s great that this code is now available to a larger audience, there
are consequences to this. :&ndash;)</p>

<h2>Telemetry and Pref Adjustments</h2>

<p>The first (and more pleasant) consequence is that we are now receiving telemetry
about the UI&rsquo;s usage patterns. This allows us to make some adjustments as the
Plugin Hang UI gets closer to the release channel. As happy as I am that this
feature will be putting users in the driver&rsquo;s seat when dealing with hung
plugins, it&rsquo;s also important to not annoy users.</p>

<p>Initially our telemetry suggested that the Plugin Hang UI frequently appeared
but then cancelled automatically because the plugin resumed execution. This
indicated to us that we should increase the default value of the
<code>dom.ipc.plugins.hangUITimeoutSecs</code> preference (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=833560">bug 833560</a>).
There has also been some discussion about scaling the Hang UI threshold depending
on hardware performance and user behaviour. This threshold is tricky to balance;
while we want users to be able to terminate a hanging plugin, we want to provide
that feature with minimal annoyance.</p>

<h2>Crashes</h2>

<p>Another consequence of the feature landing is that we received reports from
Nightly and Aurora showing that the Plugin Hang UI was inducing crashes in the
browser itself. Unfortunately the only thing that the stack traces were telling
us was that the browser-side code that hosts out-of-process plugins was not
being cleaned up properly after forcibly terminating the plugin container. We
didn&rsquo;t have any steps to reproduce. What broke this mystery wide open was when
our crash stats were finally able to show some correlations. I learned that
nearly 50% of the crashes happened on single-core CPUs.</p>

<h3>The Problem</h3>

<p>Once I was able to test this out for myself, the issue revealed itself in short order.
Fortunately for me, even though the problem involved thread scheduling, I was still able
to reproduce it in a debugger. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=828034#c8">This patch</a>
took care of the problem.</p>

<p>There&rsquo;s a bit of nuance to what was happening with this crash. When
<code>plugin-container.exe</code> is forcibly terminated, cleanup of the browser-facing
plugin code may be executed in one of two different sequences:</p>

<h3>Sequence 1 (Most common)</h3>

<ol>
<li><p>After terminating <code>plugin-container.exe</code>, the Plugin Hang UI posts a
<code>CleanupFromTimeout</code> work item to the main thread. Concurrently on the
I/O thread, Firefox&rsquo;s <code>RPCChannel</code> detects an error and posts a
<code>OnNotifyMaybeChannelError</code> work item.</p></li>
<li><p><code>OnNotifyMaybeChannelError</code> executes and sets the channel&rsquo;s state to
<code>ChannelError</code>. It also cleans up the <code>PluginModuleParent</code> actor and its
actors for subprotocols.</p></li>
<li><p><code>CleanupFromTimeout</code> runs and attempts to Close the channel. This
is effectively a no-op since the channel was already closed with an
error status by step 2.</p></li>
</ol>


<h3>Sequence 2 (Less common unless running on fewer cores)</h3>

<ol>
<li><p>Same as in Sequence 1.</p></li>
<li><p><code>CleanupFromTimeout</code> runs before <code>OnNotifyMaybeChannelError</code>. This
work item attempts to do a regular <code>Close</code> on the channel. Since the
channel&rsquo;s state is still set to <code>ChannelConnected</code>, the close operation
doesn&rsquo;t realize that it needs to do additonal cleanup. It performs
a clean shutdown of the RPC channel without properly cleaning up the
IPDL actors.</p></li>
<li><p><code>OnMaybeNotifyChannelError</code> runs, sees the channel is already closed
due to the activities in step 2, and does nothing.</p></li>
<li><p>A crash later occurs because the actors were never cleaned up properly.</p></li>
</ol>


<h3>Some Additional Analysis</h3>

<p>Sequence 2 cannot crash if the <code>plugin-container.exe</code> process is terminated
by the main thread. This is because <code>PluginModuleParent::ShouldContinueFromReplyTimeout</code>
returns <code>false</code> in this case and the channel&rsquo;s state is set to <code>ChannelTimeout</code> by
the time that the <code>CleanupFromTimeout</code> work item executes. This guarantees that
a full cleanup will be done by <code>CleanupFromTimeout</code>.</p>

<p>With the Plugin Hang UI, <code>plugin-container.exe</code> is not terminated by the main
thread, so the channel&rsquo;s state must be explicitly updated after termination.</p>

<h3>Solution</h3>

<p>The patch modifies the <code>CleanupFromTimeout</code> work item so that if the
plugin container was terminated outside the main thread, the channel is
explicitly closed with an error state. This ensures that the actors are
properly cleaned up.</p>

<h2>Hangs</h2>

<p>I filed <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=834127">bug 834127</a>
when QA discovered that sometimes the Plugin Hang UI was not being displayed.
I found out that Firefox was correctly spawning <code>plugin-hang-ui.exe</code>, however
it was not showing any UI.</p>

<p>This lead be back down the input queue rabbit hole that I briefly discussed
last time. I learned that on an intermittent basis, the Plugin Hang UI dialog
box was being hung up on Win32 <code>ShowWindow</code> and <code>SetFocus</code> calls. What I did
know was that my attempts to explicitly detach the Plugin Hang UI&rsquo;s thread
from the hung Firefox thread weren&rsquo;t working as well as I would have liked.</p>

<p>After <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=834127#c9">numerous attempts</a>
at fixing these issues, I determined that for the time being we will need to
rescind the owner-owned relationship between Firefox and the Plugin Hang UI
dialog. If we didn&rsquo;t do so, seemingly benign actions like calling <code>PeekMessage</code>
or passing a <code>WM_NCLBUTTONDOWN</code> message to <code>DefWindowProc</code> would be enough
to bring the Plugin Hang UI to a halt. Why is this, you ask? I decided to
peek into kernel mode to find out.</p>

<h3>Adventures in Kernel Mode</h3>

<p>Recall that the guts of <code>USER32</code> and <code>GDI32</code> were moved into kernel mode
via <code>win32k.sys</code> in the Windows NT 3.5 timeframe. It follows that any
efforts to examine Win32 internals necessitates peering into kernel mode.
I didn&rsquo;t need an elaborate remote debugging setup for my purposes, so I
used <a href="http://technet.microsoft.com/en-us/sysinternals/bb897415">Sysinternals LiveKd</a>
to take a snapshot of my kernel and debug it.</p>

<p>My workflow was essentially as follows:</p>

<ol>
<li>Plugin Hang UI gets stuck</li>
<li>Attach a debugger (I use WinDbg) to <code>plugin-hang-ui.exe</code></li>
<li>Run LiveKd</li>
<li>Type <code>!thread -t &lt;tid&gt;</code> into the kernel debugger, where <code>&lt;tid&gt;</code> is the
thread ID that is hung in the user-mode WinDbg</li>
</ol>


<p>Every kernel-mode call stack that I examined on a hung thread usually ended up going through this code path:</p>

<pre><samp>
...
Child-SP          RetAddr           : Args to Child                                                           : Call Site
fffff880`0def3ec0 fffff800`0327c652 : fffffa80`079c43c0 fffffa80`079c43c0 00000000`00000000 fffffa80`00000008 : nt!KiSwapContext+0x7a
fffff880`0def4000 fffff800`0328da9f : fffffd54`0000000c fffffd54`000002a0 000002ac`00000000 00000804`fffffd54 : nt!KiCommitThreadWait+0x1d2
fffff880`0def4090 fffff800`03278a14 : 00000000`00000000 00000000`00000005 00000000`00000000 fffff800`03279600 : nt!KeWaitForSingleObject+0x19f
fffff880`0def4130 fffff800`03279691 : fffffa80`079c43c0 fffffa80`079c4410 00000000`00000000 00000000`00000000 : nt!KiSuspendThread+0x54
fffff880`0def4170 fffff800`0327c85d : fffffa80`079c43c0 00000000`00000000 fffff800`032789c0 00000000`00000000 : nt!KiDeliverApc+0x201
fffff880`0def41f0 fffff800`0328da9f : fffffa80`0a7510e0 fffff800`0327c26f fffffa80`00000000 fffff800`03402e80 : nt!KiCommitThreadWait+0x3dd
fffff880`0def4280 fffff960`0010d457 : fffff900`c2255200 00000000`0000000d 00000000`00000001 00000000`00000000 : nt!KeWaitForSingleObject+0x19f
fffff880`0def4320 fffff960`0010d4f1 : fffff880`0def0000 fffff900`c08e0e20 00000000`00000000 00000000`00000000 : win32k!xxxRealSleepThread+0x257
fffff880`0def43c0 fffff960`000c46d3 : 00000000`00000000 fffff900`c093ee90 00000000`00000200 00000000`00000046 : win32k!xxxSleepThread+0x59
fffff880`0def43f0 fffff960`0010c53e : fffff900`c093ee90 fffff900`c08e0e20 00000000`00000000 fffff900`c25724b0 : win32k!xxxInterSendMsgEx+0x112a
fffff880`0def4500 fffff960`000d8ccf : fffff900`c25724b0 fffff900`c25724b0 <mark>00000000`003c031a</mark> fffff900`c0800b90 : win32k!xxxSendMessageTimeout+0x1de
fffff880`0def45b0 fffff960`000dae0b : fffff960`00000006 fffff880`0def47c0 fffff960`00000000 fffff900`00000000 : win32k!xxxCalcValidRects+0x1a3
fffff880`0def46f0 fffff960`000dac3a : fffff900`00000001 fffff900`c08e0e20 fffff880`0def49b8 fffff900`00000000 : win32k!xxxEndDeferWindowPosEx+0x18f
fffff880`0def47b0 fffff960`000d6e09 : 00000000`00000000 00000000`00000001 fffff900`00000000 fffff800`00000000 : win32k!xxxSetWindowPos+0x156
fffff880`0def4830 fffff960`0007c66d : fffff900`00000000 fffff900`0004366c fffff900`00000000 fffff900`c209f410 : win32k!xxxActivateThisWindow+0x441
...
</samp></pre>


<p>The highlighted hexadecimal value above is a handle to a window with class
<code>MSCTFIME UI</code> (i.e. a Microsoft IME window) that was created by the main
UI thread in the hung Flash process. Despite my best efforts to try to
disconnect the Plugin Hang UI input queue from these threads, Windows is
insistent on sending a synchronous, inter-thread message to the IME window
on the hung Flash thread. This doesn&rsquo;t happen if we omit setting Firefox&rsquo;s
<code>HWND</code> as the Plugin Hang UI&rsquo;s owner window.</p>

<h3>Implications</h3>

<p>Now that the Plugin Hang UI specifies a <code>NULL</code> owner, Windows can no longer
guarantee that the Plugin Hang UI will always appear above the Firefox window
that was active at the time that the plugin hang occurred. Having said that,
our experiments have shown that Windows does not try to promote an unresponsive
window to the front of the Z-order.</p>

<p>In a multiple-window situation, Windows may move the other, inactive Firefox
windows ahead of the Plugin Hang UI in the Z-order, but the window that was
active when Firefox first hung does not move. I think that this is acceptable.
In fact, the same behavour would be observable if we had been able to specify
an owner.</p>

<p>If you&rsquo;re interested in helping to test this feature, please install Nightly
and try the repro from <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=834127#c0">bug 834127</a>.
When the Plugin Hang UI fires, try to move around the Plugin Hang UI as well
as the other windows on your desktop, including Firefox. If the Z-order changes
differently from the way that I have observed here, please try to generate
some steps to reproduce, drop me a line (aklotz on <code>#perf</code> or MoCo email)
and let me know what&rsquo;s going on. Thanks!</p>
]]></content>
  </entry>
  
</feed>
