<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mozilla | Aaron Klotz at Mozilla]]></title>
  <link href="http://dblohm7.ca/blog/categories/mozilla/atom.xml" rel="self"/>
  <link href="http://dblohm7.ca/"/>
  <updated>2016-01-26T12:45:46-07:00</updated>
  <id>http://dblohm7.ca/</id>
  <author>
    <name><![CDATA[Aaron Klotz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Announcing mozdbgext]]></title>
    <link href="http://dblohm7.ca/blog/2016/01/26/announcing-mozdbgext/"/>
    <updated>2016-01-26T12:45:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2016/01/26/announcing-mozdbgext</id>
    <content type="html"><![CDATA[<p>A well-known problem at Mozilla is that, while most of our desktop users run
Windows, most of Mozilla&rsquo;s developers do not. There are a lot of problems that
result from that, but one of the most frustrating to me is that sometimes
those of us that actually use Windows for development find ourselves at a
disadvantage when it comes to tooling or other productivity enhancers.</p>

<p>In many ways this problem is also a Catch-22: People don&rsquo;t want to use Windows
for many reasons, but tooling is big part of the problem. OTOH, nobody is
motivated to improve the tooling situation if nobody is actually going to
use them.</p>

<p>A couple of weeks ago my frustrations with the situation boiled over when I
learned that our <code>Cpp</code> unit test suite could not log symbolicated call stacks,
resulting in my filing of <a title="cppunittests do not look up breakpad symbols for logged stack traces" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1238305">bug 1238305</a> and <a title="Set _NT_SYMBOL_PATH on Windows test machines" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1240605">bug 1240605</a>. Not only could we
not log those stacks, in many situations we could not view them in a debugger
either.</p>

<p>Due to the fact that PDB files consume a large amount of disk space, we don&rsquo;t
keep those when building from integration or try repositories. Unfortunately
they are be quite useful to have when there is a build failure. Most of our
integration builds, however, do include breakpad symbols. Developers may also
explicitly <a href="https://wiki.mozilla.org/ReleaseEngineering/TryServer#Getting_debug_symbols">request symbols</a>
for their try builds.</p>

<p>A couple of years ago I had begun working on a WinDbg debugger extension that
was tailored to Mozilla development. It had mostly bitrotted over time, but I
decided to resurrect it for a new purpose: to help WinDbg<sup><a href="#fn1" id="r1">*</a></sup>
grok breakpad.</p>

<h2>Enter mozdbgext</h2>

<p><a href="https://github.com/dblohm7/mozdbgext"><code>mozdbgext</code></a> is the result. This extension
adds a few commands that makes Win32 debugging with breakpad a little bit easier.</p>

<p>The original plan was that I wanted <code>mozdbgext</code> to load breakpad symbols and then
insert them into the debugger&rsquo;s symbol table via the <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff537943%28v=vs.85%29.aspx"><code>IDebugSymbols3::AddSyntheticSymbol</code></a>
API. Unfortunately the design of this API is not well equipped for bulk loading
of synthetic symbols: each individual symbol insertion causes the debugger to
re-sort its entire symbol table. Since <code>xul.dll</code>&rsquo;s quantity of symbols is in the
six-figure range, using this API to load that quantity of symbols is
prohibitively expensive. I tweeted a Microsoft PM who works on Debugging Tools
for Windows, asking if there would be any improvements there, but it sounds like
this is not going to be happening any time soon.</p>

<p>My original plan would have been ideal from a UX perspective: the breakpad
symbols would look just like any other symbols in the debugger and could be
accessed and manipulated using the same set of commands. Since synthetic symbols
would not work for me in this case, I went for &ldquo;Plan B:&rdquo; Extension commands that
are separate from, but analagous to, regular WinDbg commands.</p>

<p>I plan to continuously improve the commands that are available. Until I have a
proper README checked in, I&rsquo;ll introduce the commands here.</p>

<h3>Loading the Extension</h3>

<ol>
<li>Use the <code>.load</code> command: <code>.load &lt;path_to_mozdbgext_dll&gt;</code></li>
</ol>


<h3>Loading the Breakpad Symbols</h3>

<ol>
<li>Extract the breakpad symbols into a directory.</li>
<li>In the debugger, enter <code>!bploadsyms &lt;path_to_breakpad_symbol_directory&gt;</code></li>
<li>Note that this command will take some time to load all the relevant symbols.</li>
</ol>


<h3>Working with Breakpad Symbols</h3>

<p><strong>Note: You must have successfully run the <code>!bploadsyms</code> command first!</strong></p>

<p>As a general guide, I am attempting to name each breakpad command similarly to
the native WinDbg command, except that the command name is prefixed by <code>!bp</code>.</p>

<ul>
<li>Stack trace: <code>!bpk</code></li>
<li>Find nearest symbol to address: <code>!bpln &lt;address&gt;</code> where <em>address</em> is specified
as a hexadecimal value.</li>
</ul>


<h3>Downloading windbgext</h3>

<p>I have pre-built a <a href="https://github.com/dblohm7/mozdbgext/blob/master/bin/mozdbgext.dll?raw=true">32-bit binary</a>
(which obviously requires 32-bit WinDbg). I have not built a 64-bit binary yet,
but the code should be source compatible.</p>

<p>Note that there are several other commands that are &ldquo;roughed-in&rdquo; at this point
and do not work correctly yet. Please stick to the documented commands at this
time.</p>

<hr />

<p><sup><a href="#r1" id="fn1">*</a></sup> When I write &ldquo;WinDbg&rdquo;, I am really
referring to any debugger in the <em>Debugging Tools for Windows</em> package,
including <code>cdb</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs from Hell: Injected Third-party Code + Detours = A Bad Time]]></title>
    <link href="http://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time/"/>
    <updated>2016-01-11T13:00:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time</id>
    <content type="html"><![CDATA[<p>Happy New Year!</p>

<p>I&rsquo;m finally getting &lsquo;round to writing about a nasty bug that I had to spend a
bunch of time with in Q4 2015. It&rsquo;s one of the more challenging problems that
I&rsquo;ve had to break and I&rsquo;ve been asked a lot of questions about it. I&rsquo;m talking
about <a title="Crash spike in CreateWindowEx with Firefox 42.0b9 on Optimus" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473">bug 1218473</a>.</p>

<h2>How This All Began</h2>

<p>In <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a> I had landed a patch to intercept calls to <code>CreateWindowEx</code>.
This was necessary because it was apparent in that bug that window subclassing
was occurring while a window was neutered (&ldquo;neutering&rdquo; is terminology that is
specific to Mozilla&rsquo;s Win32 IPC code).</p>

<p>While I&rsquo;ll save a discussion on the specifics of window neutering for another
day, for our purposes it is sufficient for me to point out that subclassing a
neutered window is bad because it creates an infinite recursion scenario with
window procedures that will eventually overflow the stack.</p>

<p>Neutering is triggered during certain types of IPC calls as soon as a message is
sent to an unneutered window on the thread making the IPC call. Unfortunately in
the case of <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, the message triggering the neutering was
<code>WM_CREATE</code>. Shortly after creating that window, the code responsible would
subclass said window. Since <code>WM_CREATE</code> had already triggered neutering, this
would result in the pathological case that triggers the stack overflow.</p>

<p>For a fix, what I wanted to do is to prevent messages that were sent immediately
during the execution of <code>CreateWindow</code> (such as <code>WM_CREATE</code>) from triggering
neutering prematurely. By intercepting calls to <code>CreateWindowEx</code>, I could wrap
those calls with a RAII object that temporarily suppresses the neutering. Since
the subclassing occurs immediately after window creation, this meant that
this subclassing operation was now safe.</p>

<p>Unfortunately, shortly after landing <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, <a title="Crash spike in CreateWindowEx with Firefox 42.0b9 on Optimus" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473">bug 1218473</a> was filed.</p>

<h2>Where to Start</h2>

<p>It wasn&rsquo;t obvious where to start debugging this. While a crash spike was clearly
correlated with the landing of <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, the crashes were occurring in
code that had nothing to do with IPC or Win32. For example, the first stack that
I looked at was <code>js::CreateRegExpMatchResult</code>!</p>

<p>When it is just not clear where to begin, I like to start by looking at our
correlation data in Socorro &ndash; you&rsquo;d be surprised how often they can bring
problems into sharp relief!</p>

<p>In this case, the correlation data didn&rsquo;t disappoint: there
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473#c10">was</a> 100% correlation
with a module called <code>_etoured.dll</code>. There was also correlation with the
presence of both NVIDIA video drivers <em>and</em> Intel video drivers. Clearly this
was a concern only when NVIDIA Optimus technology was enabled.</p>

<p>I also had a pretty strong hypothesis about what <code>_etoured.dll</code> was: For many
years, Microsoft Research has shipped a package called
<a href="http://research.microsoft.com/en-us/projects/detours/">Detours</a>. Detours is a
library that is used for intercepting Win32 API calls. While the changelog for
Detours 3.0 points out that it has &ldquo;Removed [the] requirement for including
<code>detoured.dll</code> in processes,&rdquo; in previous versions of the package, this library
was required to be injected into the target process.</p>

<p>I concluded that <code>_etoured.dll</code> was most likely a renamed version of
<code>detoured.dll</code> from Detours 2.x.</p>

<h2>Following The Trail</h2>

<p>Now that I knew the likely culprit, I needed to know how it was getting there.
During a November trip to the Mozilla Toronto office, I spent some time
debugging a test laptop that was configured with Optimus.</p>

<p>Knowing that the presence of Detours was somehow interfering with our own API
interception, I decided to find out whether it was also trying to intercept
<code>CreateWindowExW</code>. I launched <code>windbg</code>, started Firefox with it, and then told
it to break as soon as <code>user32.dll</code> was loaded:</p>

<pre><samp>
sxe ld:user32.dll
</samp></pre>


<p>Then I pressed <code>F5</code> to resume execution. When the debugger broke again, this
time <code>user32</code> was now in memory. I wanted the debugger to break as soon as
<code>CreateWindowExW</code> was touched:</p>

<pre><samp>
ba w 4 user32!CreateWindowExW
</samp></pre>


<p>Once again I resumed execution. Then the debugger broke on the memory access and
gave me this call stack:</p>

<pre><samp>
nvd3d9wrap!setDeviceHandle+0x1c91
nvd3d9wrap!initialise+0x373
nvd3d9wrap!setDeviceHandle+0x467b
nvd3d9wrap!setDeviceHandle+0x4602
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
KERNELBASE!LoadLibraryExA+0x26
kernel32!LoadLibraryA+0xba
nvinit+0x11cb
nvinit+0x5477
nvinit!nvCoprocThunk+0x6e94
nvinit!nvCoprocThunk+0x6e1a
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
kernel32!BasepLoadAppInitDlls+0x167
kernel32!LoadAppInitDlls+0x82
USER32!ClientThreadSetup+0x1f9
USER32!__ClientThreadSetup+0x5
ntdll!KiUserCallbackDispatcher+0x2e
GDI32!GdiDllInitialize+0x1c
USER32!_UserClientDllInitialize+0x32f
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
firefox!XPCOMGlueLoad+0x23c
firefox!XPCOMGlueStartup+0x1d
firefox!InitXPCOMGlue+0xba
firefox!NS_internal_main+0x5c
firefox!wmain+0xbe
firefox!__tmainCRTStartup+0xfe
kernel32!BaseThreadInitThunk+0xe
ntdll!__RtlUserThreadStart+0x70
ntdll!_RtlUserThreadStart+0x1b
</samp></pre>


<p>This stack is a gold mine of information. In particular, it tells us the
following:</p>

<ol>
<li><p>The offending DLLs are being injected by <code>AppInit_DLLs</code> (and in fact, Raymond
Chen <a href="https://blogs.msdn.microsoft.com/oldnewthing/20140422-00/?p=1173">has blogged about</a>
this exact case in the past).</p></li>
<li><p><code>nvinit.dll</code> is the name of the DLL that is injected by step 1.</p></li>
<li><p><code>nvinit.dll</code> loads <code>nvd3d9wrap.dll</code> which then uses Detours to patch
our copy of <code>CreateWindowExW</code>.</p></li>
</ol>


<p>I then became curious as to which other functions they were patching.</p>

<p>Since Detours is patching executable code, we know that at some point it is
going to need to call <code>VirtualProtect</code> to make the target code writable. In the
worst case, <code>VirtualProtect</code>&rsquo;s caller is going to pass the address of the page
where the target code resides. In the best case, the caller will pass in the
address of the target function itself!</p>

<p>I restarted <code>windbg</code>, but this time I set a breakpoint on <code>VirtualProtect</code>:</p>

<pre><samp>
bp kernel32!VirtualProtect
</samp></pre>


<p>I then resumed the debugger and examined the call stack every time it broke.
While not every single <code>VirtualProtect</code> call would correspond to a detour, it
would be obvious when it was, as the NVIDIA DLLs would be on the call stack.</p>

<p>The first time I caught a detour, I examined the address being passed to
<code>VirtualProtect</code>: I ended up with the best possible case: the address was
pointing to the actual target function! From there I was able to distill a
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473#c39">list</a> of other
functions being hooked by the injected NVIDIA DLLs.</p>

<h2>Putting it all Together</h2>

<p>By this point I knew who was hooking our code and knew how it was getting there.
I also noticed that <code>CreateWindowEx</code> is the only function that the NVIDIA DLLs
and our own code were both trying to intercept. Clearly there was some kind of
bad interaction occurring between the two interception mechanisms, but what was
it?</p>

<p>I decided to go back and examine a
<a href="https://crash-stats.mozilla.com/report/index/e884dc17-957f-4270-86ab-f59742151113">specific</a>
crash dump. In particular, I wanted to examine three different memory locations:</p>

<ol>
<li>The first few instructions of <code>user32!CreateWindowExW</code>;</li>
<li>The first few instructions of <code>xul!CreateWindowExWHook</code>; and</li>
<li>The site of the call to <code>user32!CreateWindowExW</code> that triggered the crash.</li>
</ol>


<p>Of those three locations, the only one that looked off was location 2:</p>

<pre><samp>
6b1f6611 56              push    esi
6b1f6612 ff15f033e975    call    dword ptr [combase!CClassCache::CLSvrClassEntry::GetDDEInfo+0x41 (75e933f0)]
6b1f6618 c3              ret
6b1f6619 7106            jno     xul!`anonymous namespace'::CreateWindowExWHook+0x6 (6b1f6621)
xul!`anonymous namespace'::CreateWindowExWHook:
6b1f661b cc              int     3
6b1f661c cc              int     3
6b1f661d cc              int     3
6b1f661e cc              int     3
6b1f661f cc              int     3
6b1f6620 cc              int     3
6b1f6621 ff              ???
</samp></pre>


<p><em>Why the hell were the first six bytes filled with breakpoint instructions?</em></p>

<p>I decided at this point to look at some source code. Fortunately Microsoft
publishes the 32-bit source code for Detours, licensed for non-profit use,
under the name &ldquo;Detours Express.&rdquo;</p>

<p>I found a copy of Detours Express 2.1 and checked out the code. First I wanted
to know where all of these <code>0xcc</code> bytes were coming from. A quick <code>grep</code> turned
up what I was looking for:</p>

<pre><code class="c++ detours.cpp start:93">inline PBYTE detour_gen_brk(PBYTE pbCode, PBYTE pbLimit)
{
    while (pbCode &lt; pbLimit) {
        *pbCode++ = 0xcc;   // brk;
    }
    return pbCode;
}
</code></pre>

<p>Now that I knew which function was generating the <code>int 3</code> instructions, I then
wanted to find its callers. Soon I found:</p>

<pre><code class="c++ detours.cpp start:1247">#ifdef DETOURS_X86
    pbSrc = detour_gen_jmp_immediate(pTrampoline-&gt;rbCode + cbTarget, pTrampoline-&gt;pbRemain);
    pbSrc = detour_gen_brk(pbSrc,
                           pTrampoline-&gt;rbCode + sizeof(pTrampoline-&gt;rbCode));
#endif // DETOURS_X86
</code></pre>

<p>Okay, so Detours writes the breakpoints out immediately after it has written a
<code>jmp</code> pointing to its trampoline.</p>

<p><em>Why is our hook function being trampolined?</em></p>

<p>The reason must be because our hook was installed first! Detours has
detected that and has decided that the best place to trampoline to the NVIDIA
hook is at the beginning of our hook function.</p>

<p><em>But Detours is using the wrong address!</em></p>

<p>We can see that because the <code>int 3</code> instructions are written out at the
<em>beginning</em> of <code>CreateWindowExWHook</code>, even though there should be a <code>jmp</code>
instruction first.</p>

<p><strong>Detours is calculating the wrong address to write its <code>jmp</code>!</strong></p>

<h2>Finding a Workaround</h2>

<p>Once I knew <em>what</em> the problem was, I needed to know more about the <em>why</em> &ndash;
only then would I be able to come up with a way to work around this problem.</p>

<p>I decided to reconstruct the scenario where both our code and Detours are trying
to hook the same function, but our hook was installed first. I would then
follow along through the Detours code to determine how it calculated the wrong
address to install its <code>jmp</code>.</p>

<p>The first thing to keep in mind is that Mozilla&rsquo;s function interception code
takes advantage of <a href="https://blogs.msdn.microsoft.com/oldnewthing/20110921-00/?p=9583">hot-patch points</a>
in Windows. If the target function begins with a <code>mov edi, edi</code> prolog, we
use a hot-patch style hook instead of a trampoline hook. I am not going to go
into detail about hot-patch hooks here &ndash; the above Raymond Chen link contains
enough details to answer your questions. For the purposes of this blog post, the
important point is that Mozilla&rsquo;s code patches the <code>mov edi, edi</code>, so NVIDIA&rsquo;s
Detours library would need to recognize and follow the <code>jmp</code>s that our code
patched in, in order to write its own <code>jmp</code> at <code>CreateWindowExWHook</code>.</p>

<p>Tracing through the Detours code, I found the place where it checks for a
hot-patch hook and follows the <code>jmp</code> if necessary. While examining a function
called <code>detour_skip_jmp</code>, I found the bug:</p>

<pre><code class="c++ detours.cpp start:124">            pbNew = pbCode + *(INT32 *)&amp;pbCode[1];
</code></pre>

<p>This code is supposed to be telling Detours where the target address of a <code>jmp</code>
is, so that Detours can follow it. <code>pbNew</code> is supposed to be the target address
of the <code>jmp</code>. <code>pbCode</code> is referencing the address <em>of the beginning of the <code>jmp</code>
instruction itself</em>. Unfortunately, with this type of <code>jmp</code> instruction, target
addresses are always relative to the address of the <em>next</em> instruction, not
the <em>current</em> instruction! Since the current <code>jmp</code> instruction is five bytes
long, Detours ends up writing its <code>jmp</code> <em>five bytes prior</em> to the intended
target address!</p>

<p>I went and checked the source code for Detours Express 3.0 to see if this had
been fixed, and indeed it had:</p>

<pre><code class="c++ detours.cpp start:163">            PBYTE pbNew = pbCode + 5 + *(INT32 *)&amp;pbCode[1];
</code></pre>

<p>That doesn&rsquo;t do much for me right now, however, since the NVIDIA stuff is still
using Detours 2.x.</p>

<p>In the case of Mozilla&rsquo;s code, there is legitimate executable code at that
incorrect address that Detours writes to. It is corrupting the last few
instructions of that function, thus explaining those mysterious crashes that
were seemingly unrelated code.</p>

<p>I confirmed this by downloading the binaries from the build that was associated
with the crash dump that I was analyzing. [As an aside, I should point out that
you need to grab the <em>identical</em> binaries for this exercise; you cannot build
from the same source revision and expect this to work due to variability that
is introduced into builds by things like PGO.]</p>

<p>The five bytes preceeding <code>CreateWindowExHookW</code> in the crash dump diverged from
those same bytes in the original binaries. I could also make out that the
overwritten bytes consisted of a <code>jmp</code> instruction.</p>

<h3>In Summary</h3>

<p>Let us now review what we know at this point:</p>

<ul>
<li>Detours 2.x doesn&rsquo;t correctly follow <code>jmp</code>s from hot-patch hooks;</li>
<li>If Detours tries to hook something that has already been hot-patched
(including legitimate hot patches from Microsoft), it will write bytes at
incorrect addresses;</li>
<li>NVIDIA Optimus injects this buggy code into everybody&rsquo;s address spaces via an
<code>AppInit_DLLs</code> entry for <code>nvinit.dll</code>.</li>
</ul>


<p>How can we best distill this into a suitable workaround?</p>

<p>One option could be to block the NVIDIA DLLs outright. In most cases this would
probably be the simplest option, but I was hesitant to do so this time. I was
concerned about the unintended consequences of blocking what, for better or
worse, is a user-mode component of NVIDIA video drivers.</p>

<p>Instead I decided to take advantage of the fact that we now know how this bug is
triggered. I have modified our API interception code such that if it detects
the presence of NVIDIA Optimus, it disables hot-patch style hooks.</p>

<p>Not only will this take care of the crash spike that started when I landed
<a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, I also expect it to take care of other crash signatures
whose relationship to this bug was not obvious.</p>

<p>That concludes this episode of <em>Bugs from Hell</em>. Until next time&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On WebExtensions]]></title>
    <link href="http://dblohm7.ca/blog/2015/08/30/on-webextensions/"/>
    <updated>2015-08-30T02:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2015/08/30/on-webextensions</id>
    <content type="html"><![CDATA[<p>There has been enough that has been said over the past week about <a href="https://blog.mozilla.org/addons/2015/08/21/the-future-of-developing-firefox-add-ons/">WebExtensions</a>
that I wasn&rsquo;t sure if I wanted to write this post. As usual, I can&rsquo;t seem to
help myself. Note the usual disclaimer that this is my personal opinion. Further
note that I have no involvement with WebExtensions at this time, so I write this
from the point of view of an observer.</p>

<h2>API? What API?</h2>

<p>I shall begin with the proposition that the legacy, non-jetpack
environment for addons is not an API. As ridiculous as some readers might
consider this to be, please humour me for a moment.</p>

<p>Let us go back to the acronym, &ldquo;API.&rdquo; <strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface.
While the usage of the term &ldquo;API&rdquo; seems to have expanded over the years to encompass
just about any type of interface whatsoever, I&rsquo;d like to explore the first letter of that
acronym: <em>Application</em>.</p>

<p>An <em>Application</em> Programming Interface is a specific type of interface that is
exposed for the purposes of building applications. It typically provides a
formal abstraction layer that isolates applications from the implementation
details behind the lower tier(s) in the software stack. In the case of web
browsers, I suggest that there are two distinct types of applications:
web content, and extensions.</p>

<p>There is obviously a very well defined API for web content. On the other hand,
I would argue that Gecko&rsquo;s legacy addon environment is not an API at all! From
the point of view of an extension, there is no abstraction, limited formality,
and not necessarily an intention to be used by applications.</p>

<p>An extension is imported into Firefox with full privileges and can access whatever
it wants. Does it have access to interfaces? Yes, but are those interfaces intended
for <em>applications</em>? Some are, but many are not. The environment that Gecko
currently provides for legacy addons is analagous to an operating system running
every single application in kernel mode. Is that powerful? Absolutely! Is that
the best thing to do for maintainability and robustness? Absolutely not!</p>

<p>Somewhere a line needs to be drawn to demarcate this abstraction layer and
improve Gecko developers&#8217; ability to make improvements under the hood. Last
week&rsquo;s announcement was an invitation to addon developers to help shape that
future. Please participate and please do so constructively!</p>

<h2>WebExtensions are not Chrome Extensions</h2>

<p>When I first heard rumors about WebExtensions in Whistler, my source made it
very clear to me that the WebExtensions initiative is not about making Chrome
extensions run in Firefox. In fact, I am quite disappointed with some of the
press coverage that seems to completely miss this point.</p>

<p>Yes, WebExtensions will be implementing some APIs to be <em>source compatible</em>
with Chrome. That makes it easier to port a Chrome extension, but porting will
still be necessary. I like the Venn Diagram concept that the <a href="https://wiki.mozilla.org/WebExtensions/FAQ">WebExtensions FAQ</a>
uses: Some Chrome APIs will not be available in WebExtensions. On the other hand,
WebExtensions will be providing APIs above and beyond the Chrome API set that
will maintain Firefox&rsquo;s legacy of extensibility.</p>

<p>Please try not to think of this project as Mozilla taking functionality away.
In general I think it is safe to think of this as an opportunity to move that
same functionality to a mechanism that is more formal and abstract.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interesting Win32 APIs]]></title>
    <link href="http://dblohm7.ca/blog/2015/07/28/interesting-win32-apis/"/>
    <updated>2015-07-28T11:30:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2015/07/28/interesting-win32-apis</id>
    <content type="html"><![CDATA[<p>Yesterday I decided to diff the export tables of some core Win32 DLLs to see what&rsquo;s
changed between Windows 8.1 and the Windows 10 technical preview. There weren&rsquo;t
many changes, but the ones that were there are quite exciting IMHO. While
researching these new APIs, I also stumbled across some others that were
added during the Windows 8 timeframe that we should be considering as well.</p>

<h2>Volatile Ranges</h2>

<p>While my diff showed these APIs as new exports for Windows 10, the MSDN docs
claim that these APIs are actually new for the Windows 8.1 Update. Using the
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn781436%28v=vs.85%29.aspx"><code>OfferVirtualMemory</code></a>
and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn781437%28v=vs.85%29.aspx"><code>ReclaimVirtualMemory</code></a>
functions, we can now specify ranges of virtual memory that are safe to
discarded under memory pressure. Later on, should we request that access be
restored to that memory, the kernel will either return that virtual memory to us
unmodified, or advise us that the associated pages have been discarded.</p>

<p>A couple of years ago we had an intern on the Perf Team who was working on
bringing this capability to Linux. I am pleasantly surprised that this is now
offered on Windows.</p>

<h2><code>madvise(MADV_WILLNEED)</code> for Win32</h2>

<p>For the longest time we have been hacking around the absence of a <code>madvise</code>-like
API on Win32. On Linux we will do a <code>madvise(MADV_WILLNEED)</code> on memory-mapped
files when we want the kernel to read ahead. On Win32, we were opening the
backing file and then doing a series of sequential reads through the file to
force the kernel to cache the file data. As of Windows 8, we can now call
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh780543%28v=vs.85%29.aspx"><code>PrefetchVirtualMemory</code></a>
for a similar effect.</p>

<h2>Operation Recorder: An API for SuperFetch</h2>

<p>The <a href="https://msdn.microsoft.com/en-us/library/hh437562%28v=vs.85%29.aspx"><code>OperationStart</code></a>
and <a href="https://msdn.microsoft.com/en-us/library/hh437558%28v=vs.85%29.aspx"><code>OperationEnd</code></a>
APIs are intended to record access patterns during a file I/O operation.
SuperFetch will then create prefetch files for the operation, enabling prefetch
capabilities above and beyond the use case of initial process startup.</p>

<h2>Memory Pressure Notifications</h2>

<p>This API is not actually new, but I couldn&rsquo;t find any invocations of it in the
Mozilla codebase. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366541%28v=vs.85%29.aspx"><code>CreateMemoryResourceNotification</code></a>
allocates a kernel handle that becomes signalled when physical memory is running
low. Gecko already has facilities for handling memory pressure events on other
platforms, so we should probably add this to the Win32 port.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WaitMessage Considered Harmful]]></title>
    <link href="http://dblohm7.ca/blog/2015/03/12/waitmessage-considered-harmful/"/>
    <updated>2015-03-12T15:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2015/03/12/waitmessage-considered-harmful</id>
    <content type="html"><![CDATA[<p>I could apologize for the clickbaity title, but I won&rsquo;t. I have no shame.</p>

<p>Today I want to talk about some code that we imported from Chromium some time
ago. I replaced it in Mozilla&rsquo;s codebase a few months back in <a title="IPC message pump for windows should use WinUtils::WaitForMessage" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1072752">bug 1072752</a>:</p>

<p><figure class='code'><figcaption><span> (message_pump_win.cc)</span> <a href='/downloads/code/message_pump_win.cc'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="c1">// A WM_* message is available.</span>
</span><span class='line'>    <span class="c1">// If a parent child relationship exists between windows across threads</span>
</span><span class='line'>    <span class="c1">// then their thread inputs are implicitly attached.</span>
</span><span class='line'>    <span class="c1">// This causes the MsgWaitForMultipleObjectsEx API to return indicating</span>
</span><span class='line'>    <span class="c1">// that messages are ready for processing (Specifically, mouse messages</span>
</span><span class='line'>    <span class="c1">// intended for the child window may appear if the child window has</span>
</span><span class='line'>    <span class="c1">// capture).</span>
</span><span class='line'>    <span class="c1">// The subsequent PeekMessages call may fail to return any messages thus</span>
</span><span class='line'>    <span class="c1">// causing us to enter a tight loop at times.</span>
</span><span class='line'>    <span class="c1">// The WaitMessage call below is a workaround to give the child window</span>
</span><span class='line'>    <span class="c1">// some time to process its input messages.</span>
</span><span class='line'>    <span class="n">MSG</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class='line'>    <span class="n">DWORD</span> <span class="n">queue_status</span> <span class="o">=</span> <span class="n">GetQueueStatus</span><span class="p">(</span><span class="n">QS_MOUSE</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">HIWORD</span><span class="p">(</span><span class="n">queue_status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">QS_MOUSE</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>        <span class="o">!</span><span class="n">PeekMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WM_MOUSEFIRST</span><span class="p">,</span> <span class="n">WM_MOUSELAST</span><span class="p">,</span> <span class="n">PM_NOREMOVE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">WaitMessage</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>This code is wrong. <strong>Very</strong> wrong.</p>

<p>Let us start with the calls to <code>GetQueueStatus</code> and <code>PeekMessage</code>. Those APIs
mark any messages already in the thread&rsquo;s message queue as having been seen,
such that they are no longer considered &ldquo;new.&rdquo; Even though those function calls
do not remove messages from the queue, any messages that were in the queue at
this point are considered to be &ldquo;old.&rdquo;</p>

<p>The logic in this code snippet is essentially saying, &ldquo;if the queue contains
mouse messages that do not belong to this thread, then they must belong to an
attached thread.&rdquo; The code then calls <code>WaitMessage</code> in an effort to give the
other thread(s) a chance to process their mouse messages. This is where the code
goes off the rails.</p>

<p>The <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644956%28v=vs.85%29.aspx">documentation</a>
for <code>WaitMessage</code> states the following:</p>

<blockquote><p>Note that <code>WaitMessage</code> does not return if there is unread input in the message
queue after the thread has called a function to check the queue. This is
because functions such as <code>PeekMessage</code>, <code>GetMessage</code>, <code>GetQueueStatus</code>,
<code>WaitMessage</code>, <code>MsgWaitForMultipleObjects</code>, and <code>MsgWaitForMultipleObjectsEx</code>
check the queue and then change the state information for the queue so that
the input is no longer considered new. A subsequent call to <code>WaitMessage</code> will
not return until new input of the specified type arrives. The existing unread
input (received prior to the last time the thread checked the queue) is ignored.</p></blockquote>

<p><code>WaitMessage</code> will only return if there is <em>a new</em> (as opposed to <em>any</em>) message
in the queue for the calling thread. Any messages for the calling thread that
were already in there at the time of the <code>GetQueueStatus</code> and <code>PeekMessage</code> calls
are no longer new, so they are ignored.</p>

<p>There might very well be a message at the head of that queue that should be
processed by the current thread. Instead it is ignored while we wait for other
threads. Here is the crux of the problem: we&rsquo;re waiting on other threads whose
input queues are attached to our own! That other thread can&rsquo;t process its
messages because our thread has messages in front of its messages; on the other
hand, our thread has blocked itself!</p>

<p>The only way to break this deadlock is for new messages to be added to the queue.
That is a big reason why we&rsquo;re seeing things like <a title="Page doesn't load/render if the mouse is not moving" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1105386">bug 1105386</a>: Moving the
mouse adds new messages to the queue, making <code>WaitMessage</code> unblock.</p>

<p>I&rsquo;ve already eliminated this code in Mozilla&rsquo;s codebase, but the challenge is
going to be getting rid of this code in third-party binaries that attach their
own windows to Firefox&rsquo;s windows.</p>
]]></content>
  </entry>
  
</feed>
