
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Aaron Klotz at Mozilla</title>
  <meta name="author" content="Aaron Klotz">

  
  <meta name="description" content="In my continuing efforts to get caught up on discussing my work, I am now
commencing a roundup for 2019. I think I am going to structure this one &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://dblohm7.ca">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Aaron Klotz at Mozilla" type="application/atom+xml">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  

<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-36293908-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-36293908-1');
  </script>


  <link href="https://dblohm7.ca/favicon.svg" rel="icon" sizes="any" type="image/svg+xml">
  <link href="https://dblohm7.ca/favicon.gif" rel="icon">
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Aaron Klotz at Mozilla</a></h1>
  
    <h2>My adventures as a member of Mozilla&#8217;s GeckoView Team</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:dblohm7.ca" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/03/01/2019-roundup-part-1/">2019 Roundup: Part 1 - Porting the DLL Interceptor to AArch64</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2021-03-01T00:00:00-07:00" pubdate data-updated="true">Mar 1st, 2021</time>
        
           | <a href="/blog/2021/03/01/2019-roundup-part-1/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2021/03/01/2019-roundup-part-1/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In my continuing efforts to get caught up on discussing my work, I am now
commencing a roundup for 2019. I think I am going to structure this one
slightly differently from the last one: I am going to try to segment this
roundup by project.</p>

<p>Here is an index of all the entries in this series:</p>

<ul>
<li><a href="https://dblohm7.ca/blog/2021/03/01/2019-roundup-part-1/">Part 1 - Porting the DLL Interceptor to AArch64</a> (this post)</li>
</ul>


<h2>Porting the DLL Interceptor to AArch64</h2>

<p>During early 2019, Mozilla was working to port Firefox to run on the new
AArch64 builds of Windows. At our December 2018 all-hands, I brought up the
necessity of including the DLL Interceptor in our porting efforts. Since no deed
goes unpunished, I was put in charge of doing the work! [<em>I&rsquo;m actually kidding
here; this project was right up my alley and I was happy to do it! &ndash; Aaron</em>]</p>

<p>Before continuing, you might want to review my <a href="https://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">previous entry</a>
describing the Great Interceptor Refactoring of 2018, as this post revisits some
of the concepts introduced there.</p>

<p>Let us review some DLL Interceptor terminology:</p>

<ul>
<li>The <em>target function</em> is the function we want to hook (Note that this is a
distinct concept from a <em>branch target</em>, which is also discussed in this post);</li>
<li>The <em>hook function</em> is our function that we want the intercepted target function
to invoke;</li>
<li>The <em>trampoline</em> is a small chunk of executable code generated by the DLL
interceptor that facilitates calling the target function&rsquo;s original implementation.</li>
</ul>


<p>On more than one occasion I had to field questions about why this work was
even necessary for AArch64: there aren&rsquo;t going to be many injected DLLs in a
Win32 ecosystem running on a shiny new processor architecture! In fact, the DLL
Interceptor is used for more than just facilitating the blocking of injected
DLLs; we also use it for other purposes.</p>

<p>Not all of this work was done in one bug: some tasks were more urgent than
others. I began this project by enumerating our extant uses of the interceptor to
determine which instances were relevant to the new AArch64 port. I threw a record
of each instance into a colour-coded spreadsheet, which proved to be very useful
for tracking progress: Reds were &ldquo;must fix&rdquo; instances, yellows were &ldquo;nice to have&rdquo;
instances, and greens were &ldquo;fixed&rdquo; instances. Coordinating with the milestones
laid out by program management, I was able to assign each instance to a bucket
which would help determine a total ordering for the various fixes. I landed the
first set of changes in <a title="nsWindowsDllInterceptor porting to aarch64" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1526383">bug 1526383</a>, and the second set in <a title="ARM64: nsWindowsDllInterceptor support for Milestone 4 (accessibility)" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1532470">bug 1532470</a>.</p>

<p>It was now time to sit down, download some AArch64 programming manuals, and
take a look at what I was dealing with. While I have been messing around with
x86 assembly since I was a teenager, my first exposure to RISC architectures was
via the <a href="https://en.wikipedia.org/wiki/DLX">DLX architecture</a> introduced by
Hennessy and Patterson in their textbooks. While DLX was crafted specifically
for educational purposes, it served for me as a great point of reference. When
I was a student taking CS 241 at the University of Waterloo, we had to write a
toy compiler that generated DLX code. That experience ended up saving me a lot
of time when looking into AArch64! While the latter is definitely more
sophisticated, I could clearly recognize analogs between the two architectures.</p>

<p>In some ways, targeting a RISC architecture greatly simplifies things: The
DLL Interceptor only needs to concern itself with a small subset of the AArch64
instruction set: loads and branches. In fact, the DLL Interceptor&rsquo;s AArch64
disassembler only looks for <a href="https://searchfox.org/mozilla-central/rev/362676fcadac37f9f585141a244a9a640948794a/mozglue/misc/interceptor/Arm64.cpp#53">nine distinct instructions</a>!
As a bonus, since the instruction length is fixed, we can easily copy over
verbatim any instructions that are not loads or branches!</p>

<p>On the other hand, one thing that <em>increased</em> complexity of the port is that
some branch instructions to relative addresses have maximum offsets. If we must
branch farther than that maximum, we must take alternate measures. For example,
in AArch64, an unconditional branch with an immediate offset must land in the
range of &plusmn;128 MiB from the current program counter.</p>

<p>Why is this a problem, you ask? Well, Detours-style interception must overwrite
the first several instructions of the target function. To write an absolute jump,
we require at least 16 bytes: 4 for an <code>LDR</code> instruction, 4 for a <code>BR</code>
instruction, and another 8 for the 64-bit absolute branch target address.</p>

<p>Unfortunately, target functions may be <em>really short</em>! Some of the target
functions that we need to patch consist only of a single 4-byte instruction!</p>

<p>In this case, our only option for patching the target is to use an immediate <code>B</code>
instruction, but that only works if our hook function falls within that &plusmn;128MiB
limit. If it does not, we need to construct a <em>veneer</em>. A veneer is a special
trampoline whose location falls within the target range of a branch instruction.
Its sole purpose is to provide an unconditional jump to the &ldquo;real&rdquo; desired
branch target that lies outside of the range of the original branch. Using
veneers, we can successfully hook a target function even if it is only one
instruction (ie, 4 bytes) in length, and the hook function lies more than 128MiB
away from it. The AArch64 Procedure Call Standard specifies <code>X16</code> as a volatile
register that is explicitly intended for use by veneers: veneers load an
absolute target address into <code>X16</code> (without needing to worry about whether or
not they&rsquo;re clobbering anything), and then unconditionally jump to it.</p>

<h3>Measuring Target Function Instruction Length</h3>

<p>To determine how many instructions the target function has for us to work with,
we make two passes over the target function&rsquo;s code. The first pass simply counts
how many instructions are available for patching (up to the 4 instruction
maximum needed for absolute branches; we don&rsquo;t really care beyond that).</p>

<p>The second pass actually populates the trampoline, builds the veneer (if
necessary), and patches the target function.</p>

<h3>Veneer Support</h3>

<p>Since the DLL interceptor is already well-equipped to build trampolines, it did
not take much effort to add support for <a href="https://searchfox.org/mozilla-central/rev/362676fcadac37f9f585141a244a9a640948794a/mozglue/misc/interceptor/Arm64.h#193">constructing veneers</a>.
However, <em>where</em> to write out a veneer is just as important as <em>what</em> to write
to a veneer.</p>

<p>Recall that we need our veneer to reside within &plusmn;128 MiB of an immediate
branch. Therefore, we need to be able to exercise some control over where
the trampoline memory for veneers is allocated. Until this point, our trampoline
allocator had no need to care about this; I had to add this capability.</p>

<h4>Adding Range-Aware VM Allocation</h4>

<p>Firstly, I needed to make the <code>MMPolicy</code> classes range-aware: we need to be able
to allocate trampoline space within acceptable distances from branch instructions.</p>

<p>Consider that, as described above, a branch instruction may have limits on the
extents of its target. As data, this is easily formatted as a <em>pivot</em> (ie, the
PC at the location where the branch instruction is encoutered), and a maximum
<em>distance</em> in either direction from that pivot.</p>

<p>On the other hand, range-constrained memory allocation tends to work in terms
of lower and upper bounds. I wrote a conversion method, <code>MMPolicyBase::SpanFromPivotAndDistance</code>,
to convert between the two formats. In addition to format conversion, this method
also constrains resulting bounds such that they are above the 1MiB mark of the
process&#8217; address space (to avoid reserving memory in VM regions that are
sensitive to compatiblity concerns), as well as below the maximum allowable
user-mode VM address.</p>

<p>Another issue with range-aware VM allocation is determining the location, within
the allowable range, for the actual VM reservation. Ideally we would like the
kernel&rsquo;s memory manager to choose the best location for us: its holistic view of
existing VM layout (not to mention ASLR) across all processes will provide
superior VM reservations. On the other hand, the Win32 APIs that facilitate this
are specific to Windows 10. When available, <code>MMPolicyInProcess</code> uses <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc2"><code>VirtualAlloc2</code></a>
and <code>MMPolicyOutOfProcess</code> uses <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile3"><code>MapViewOfFile3</code></a>.
When we&rsquo;re running on Windows versions where those APIs are not yet available,
we need to fall back to finding and reserving our own range. The
<code>MMPolicyBase::FindRegion</code> method handles this for us.</p>

<p>All of this logic is wrapped up in the <code>MMPolicyBase::Reserve</code> method. In
addition to the desired VM size and range, the method also accepts two functors
that wrap the OS APIs for reserving VM. <code>Reserve</code> uses those functors when
available, otherwise it falls back to <code>FindRegion</code> to manually locate a suitable
reservation.</p>

<p>Now that our memory management primatives were range-aware, I needed to shift my
focus over to our VM sharing policies.</p>

<p>One impetus for the Great Interceptor Refactoring was to enable separate
Interceptor instances to share a unified pool of VM for trampoline memory.
To make this range-aware, I needed to make some additional changes to
<code>VMSharingPolicyShared</code>. It would no longer be sufficient to assume that we
could just share a single block of trampoline VM &mdash; we now needed to make the
shared VM policy capable of potentially allocating multiple blocks of VM.</p>

<p><code>VMSharingPolicyShared</code> now contains a mapping of ranges to VM blocks. If we
request a reservation which an existing block satisfies, we re-use that block.
On the other hand, if we require a range that is yet unsatisfied, then we need to
allocate a new one. I admit that I kind of half-assed the implementation of the
data structure we use for the mapping; I was too lazy to implement a fully-fledged
interval tree. The current implementation is probably &ldquo;good enough,&rdquo; however
it&rsquo;s probably worth fixing at some point.</p>

<p>Finally, I added a new generic class, <code>TrampolinePool</code>, that acts as an
abstraction of a reserved block of VM address space. The main interceptor code
requests a pool by calling the VM sharing policy&rsquo;s <code>Reserve</code> method, then it
uses the pool to retrieve new <code>Trampoline</code> instances to be populated.</p>

<h3>AArch64 Trampolines</h3>

<p>It is much simpler to generate trampolines for AArch64 than it is for x86(-64).
The most noteworthy addition to the <code>Trampoline</code> class is the <code>WriteLoadLiteral</code>
method, which writes an absolute address into the trampoline&rsquo;s literal pool,
followed by writing an <code>LDR</code> instruction referencing that literal into the
trampoline.</p>

<hr />

<p>Thanks for reading! Coming up next time: My Untrusted Modules Opus.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/02/24/2018-roundup-h2/">2018 Roundup: H2 - Preparing to Enable the Launcher Process by Default</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2021-02-24T00:00:00-07:00" pubdate data-updated="true">Feb 24th, 2021</time>
        
           | <a href="/blog/2021/02/24/2018-roundup-h2/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2021/02/24/2018-roundup-h2/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>This is the fifth post in my &ldquo;2018 Roundup&rdquo; series. For an index of all entries, please see my
blog entry for <a href="https://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Q1</a>.</em></p>

<p>Yes, you are reading the dates correctly: I am posting this over two years after I began this series.
I am trying to get caught up on documenting my past work!</p>

<h3>CI and Developer Tooling</h3>

<p>Given that the launcher process completely changes how our Win32 Firefox builds
start, I needed to update both our CI harnesses, as well as the launcher process
itself. I didn&rsquo;t do much that was particularly noteworthy from a technical
standpoint, but I will mention some important points:</p>

<p>During normal use, the launcher process usually exits immediately after the
browser process is confirmed to have started. This was a deliberate design
decision that I made. Having the launcher process wait for the browser process
to terminate would not do any harm, however I did not want the launcher process
hanging around in Task Manager and being misunderstood by users who are checking
their browser&rsquo;s resource usage.</p>

<p>On the other hand, such a design completely breaks scripts that expect to start
Firefox and be able to synchronously wait for the browser to exit before
continuing! Clearly I needed to provide an opt-in for the latter case, so I added
the <code>--wait-for-browser</code> command-line option. The launcher process also implicitly
enables this mode under a few <a href="https://searchfox.org/mozilla-central/rev/31a3457890b5698af1277413ee9d9bd6c5955183/browser/app/winlauncher/LauncherProcessWin.cpp#92">other scenarios</a>.</p>

<p>Secondly, there is the issue of debugging. Developers were previously used to
attaching to the first <code>firefox.exe</code> process they see and expecting to be debugging
the browser process. With the launcher process enabled by default, this is no
longer the case.</p>

<p>There are few options here:</p>

<ul>
<li>Visual Studio users may install the <a href="https://devblogs.microsoft.com/devops/introducing-the-child-process-debugging-power-tool/">Child Process Debugging Power Tool</a>,
which enables the VS debugger to attach to child processes;</li>
<li>WinDbg users may start their debugger with the <code>-o</code> command-line flag,
or use the <code>Debug child processes also</code> checkbox in the GUI;</li>
<li>I added support for a <code>MOZ_DEBUG_BROWSER_PAUSE</code> environment variable, which
allows developers to set a timeout (in seconds) for the browser process to
print its pid to <code>stdout</code> and wait for a debugger attachment.</li>
</ul>


<h3>Performance Testing</h3>

<p>As I have alluded to in previous posts, I needed to measure the effect of adding
an additional process to the critical path of Firefox startup. Since in-process
testing will not work in this case, I needed to use something that could provide
a holistic view across both launcher and browser processes. I decided to enhance
our existing <code>xperf</code> suite in Talos to support my use case.</p>

<p>I already had prior experience with <code>xperf</code>; I spent a significant part of 2013
working with Joel Maher to put the <code>xperf</code> Talos suite into production. I also
knew that the existing code was not sufficiently generic to be able to handle my
use case.</p>

<p>I threw together a rudimentary <a href="https://github.com/dblohm7/xperf">analysis framework</a>
for working with CSV-exported xperf data. Then, after Joel&rsquo;s review, I vendored
it into <code>mozilla-central</code> and used it to construct an analysis for startup time.
[<em>While a more thorough discussion of this framework is definitely warranted, I
also feel that it is tangential to the discussion at hand; I&rsquo;ll write a dedicated
blog entry about this topic in the future. &ndash; Aaron</em>]</p>

<p>In essence, the analysis considers the following facts when processing an xperf recording:</p>

<ul>
<li>The launcher process will be the first <code>firefox.exe</code> process that runs;</li>
<li>The browser process will be started by the launcher process;</li>
<li>The browser process will fire a <a href="https://searchfox.org/mozilla-central/source/toolkit/components/startup/mozprofilerprobe.mof">session store window restored</a> event.</li>
</ul>


<p>For our analysis, we needed to do the following:</p>

<ol>
<li>Find the event showing the first <code>firefox.exe</code> process being created;</li>
<li>Find the session store window restored event from the second process;</li>
<li>Output the time interval between the two events.</li>
</ol>


<p><a href="https://searchfox.org/mozilla-central/rev/31a3457890b5698af1277413ee9d9bd6c5955183/testing/talos/talos/xtalos/parse_xperf.py#36">This block of code</a>
demonstrates how that analysis is specified using my analyzer framework.</p>

<p>Overall, these test results were quite positive. We saw a very slight but
imperceptible increase in startup time on machines with solid-state drives,
however the security benefits from the launcher process outweigh this very small
regression.</p>

<p>Most interestingly, we saw a signficant <em>improvement</em> in startup time on Windows
10 machines with magnetic hard disks! As I mentioned in Q2 Part 3, I believe
this improvement is due to reduced hard disk seeking thanks to the launcher
process forcing <code>\windows\system32</code> to the front of the dynamic linker&rsquo;s search
path.</p>

<h3>Error and Experimentation Readiness</h3>

<p>By Q3 I had the launcher process in a state where it was built by default into
Firefox, but it was still opt-in. As I have written previously, we needed the
launcher process to gracefully fail even without having the benefit of various
Gecko services such as preferences and the crash reporter.</p>

<h4>Error Propagation</h4>

<p>First of call, I created a new class, <a href="https://searchfox.org/mozilla-central/rev/31a3457890b5698af1277413ee9d9bd6c5955183/widget/windows/WinHeaderOnlyUtils.h#73"><code>WindowsError</code></a>,
that encapsulates all types of Windows error codes. As an aside, I would strongly
encourage all Gecko developers who are writing new code that invokes Windows APIs
to use this class in your error handling.</p>

<p><code>WindowsError</code> is currently able to store Win32 <code>DWORD</code> error codes, <code>NTSTATUS</code>
error codes, and <code>HRESULT</code> error codes. Internally the code is stored as an
<code>HRESULT</code>, since that type has encodings to support the other two. <code>WindowsError</code>
also provides a method to convert its error code to a localized string for
human-readable output.</p>

<p>As for the launcher process itself, nearly every function in the launcher
process returns a <code>mozilla::Result</code>-based type. In case of error, we return a
<code>LauncherResult</code>, which [<em>as of 2018; this has changed more recently &ndash; Aaron</em>]
is a structure containing the error&rsquo;s source file, line number, and <code>WindowsError</code>
describing the failure.</p>

<h4>Detecting Browser Process Failures</h4>

<p>While all <code>Result</code>s in the launcher process may be indicating a successful
start, we may not yet be out of the woods! Consider the possibility that the
various interventions taken by the launcher process might have somehow impaired
the browser process&#8217; ability to start!</p>

<p>To deal with this situation, the launcher process and the browser process share
code that tracks whether both processes successfully started in sequence.</p>

<p>When the launcher process is started, it checks information recorded about the
previous run. If the browser process previously failed to start correctly, the
launcher process disables itself and proceeds to start the browser process
without any of its typical interventions.</p>

<p>Once the browser has successfully started, it reflects the launcher process
state into telemetry, preferences, and <code>about:support</code>.</p>

<p>Future attempts to start Firefox will bypass the launcher process until the
next time the installation&rsquo;s binaries are updated, at which point we reset and
attempt once again to start with the launcher process. We do this in the hope
that whatever was failing in version <em>n</em> might be fixed in version <em>n + 1</em>.</p>

<p>Note that this update behaviour implies that there is no way to forcibly and
permanently disable the launcher process. This is by design: the error detection
feature is designed to prevent the browser from becoming unusable, not to provide
configurability. The launcher process is a security feature and not something
that we should want users adjusting any more than we would want users to be
disabling the capability system or some other important security mitigation. In
fact, my original roadmap for InjectEject called for eventually removing the
failure detection code if the launcher failure rate ever reached zero.</p>

<h4>Experimentation and Emergency</h4>

<p>The pref reflection built into the failure detection system is bi-directional.
This allowed us to ship a release where we ran a study with a fraction of users
running with the launcher process enabled by default.</p>

<p>Once we rolled out the launcher process at 100%, this pref also served as a
useful &ldquo;emergency kill switch&rdquo; that we could have flipped if necessary.</p>

<p>Fortunately our experiments were successful and we rolled the launcher process
out to release at 100% without ever needing the kill switch!</p>

<p>At this point, this pref should probably be removed, as we no longer need nor
want to control launcher process deployment in this way.</p>

<h4>Error Reporting</h4>

<p>When telemetry is enabled, the launcher process is able to convert its
<code>LauncherResult</code> into a ping which is sent in the background by <code>ping-sender</code>.
When telemetry is disabled, we perform a last-ditch effort to surface the error
by logging details about the <code>LauncherResult</code> failure in the Windows Event Log.</p>

<h3>In Conclusion</h3>

<p>Thanks for reading! This concludes my 2018 Roundup series! There is so much more
work from 2018 that I did for this project that I wish I could discuss, but for
security reasons I must refrain. Nonetheless, I hope you enjoyed this series.
Stay tuned for more roundups in the future!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/01/05/2018-roundup-q2-part3/">2018 Roundup: Q2, Part 3 - Fleshing Out the Launcher Process</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2021-01-05T00:00:00-07:00" pubdate data-updated="true">Jan 5th, 2021</time>
        
           | <a href="/blog/2021/01/05/2018-roundup-q2-part3/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2021/01/05/2018-roundup-q2-part3/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>This is the fourth post in my &ldquo;2018 Roundup&rdquo; series. For an index of all entries, please see my
blog entry for <a href="https://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Q1</a>.</em></p>

<p>Yes, you are reading the dates correctly: I am posting this nearly two years after I began this series.
I am trying to get caught up on documenting my past work!</p>

<p>Once I had landed the <a href="https://dblohm7.ca/blog/2021/01/04/2018-roundup-q2-part2/">skeletal implementation</a>
of the launcher process, it was time to start making it do useful things.</p>

<h3>Ensuring Medium Integrity</h3>

<p>[<em>For an overview of Windows integrity levels, check out <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control">this MSDN page</a> &ndash; Aaron</em>]</p>

<p>Since Windows Vista, security tokens for standard users have run at a medium integrity level (IL) by default.
When UAC is enabled, members of the <code>Administrators</code> group also run as a standard user with a medium IL, with
the additional ability of being able to &ldquo;elevate&rdquo; themselves to a high IL. When UAC is disabled, an administrator
receives a token that always runs at the high integrity level.</p>

<p>Running a process at a high IL is something that is not to be taken lightly: at that level, the process may
alter system settings and access files that would otherwise be restricted by the OS.</p>

<p>While our sandboxed content processes always run at a low IL, I believed that defense-in-depth called for ensuring
that the browser process did not run at a high IL. In particular, I was concerned about cases where elevation
might be accidental. Consider, for example, a hypothetical scenario where a system administrator is running two
open command prompts, one elevated and one not, and they accidentally start Firefox from the one that is elevated.</p>

<p>This was a perfect use case for the launcher process: it detects whether it is running at high IL, and if so,
it launches the browser with medium integrity.</p>

<p>Unfortunately some users prefer to configure their accounts to run at all times as <code>Administrator</code> with high integrity!
This is <em>terrible</em> idea from a security perspective, but it is what it is; in my experience, most users who
run with this configuration do so deliberately, and they have no interest in being lectured about it.</p>

<p>Unfortunately, users running under this account configuration will experience side-effects of the Firefox browser
process running at medium IL. Specifically, a medium IL process is unable to initiate IPC connections with a process
running at a higher IL. This will break features such as drag-and-drop, since even the administrator&rsquo;s shell processes are running
at a higher IL than Firefox.</p>

<p>Being acutely aware of this issue, I included an escape hatch for these users: I implemented a command line option
that prevents the launcher process from de-elevating when running with a high IL. I hate that I needed to do this,
but moral suasion was not going to be an effective technique for solving this problem.</p>

<h3>Process Mitigation Policies</h3>

<p>Another tool that the launcher process enables us to utilize is process mitigation options. Introduced in Windows 8,
the kernel provides several opt-in flags that allows us to add prophylactic policies to our processes in an effort to
harden them against attacks.</p>

<p>Additional flags have been added over time, so we must be careful to only set flags that are supported by the version
of Windows on which we&rsquo;re running.</p>

<p>We could have set some of these policies by calling the
<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy"><code>SetProcessMitigationPolicy</code></a> API.
Unfortunately this API is designed for a process to use on itself once it is already running. This implies that there
is a window of time between process creation and the time that the process enables its mitigations where an attack could occur.</p>

<p>Fortunately, Windows provides a second avenue for setting process mitigation flags: These flags may be set as part of
an attribute list in the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/ns-winbase-startupinfoexw"><code>STARTUPINFOEX</code></a>
structure that we pass into <code>CreateProcess</code>.</p>

<p>Perhaps you can now see where I am going with this: The launcher process enables us to specify process mitigation flags
for the browser process <em>at the time of browser process creation</em>, thus preventing the aforementioned window of opportunity
for attacks to occur!</p>

<p>While there are other flags that we could support in the future, the initial mitigation policy that I added was the
<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute"><code>PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_ALWAYS_ON</code></a>
flag. [<em>Note that I am only discussing flags applied to the browser process; sandboxed processes receive additional mitigations. &ndash; Aaron</em>]
This flag forces the Windows loader to always use the Windows <code>system32</code> directory as the first directory in its search path,
which prevents library preload attacks. Using this mitigation also gave us an unexpected performance gain on devices with
magnetic hard drives: most of our DLL dependencies are either loaded using absolute paths, or reside in <code>system32</code>. With
<code>system32</code> at the front of the loader&rsquo;s search path, the resulting reduction in hard disk seek times produced a slight but
meaningful decrease in browser startup time! How I made these measurements is addressed in a future post.</p>

<h3>Next Time</h3>

<p>This concludes the Q2 topics that I wanted to discuss. Thanks for reading! Coming up in <a href="https://dblohm7.ca/blog/2021/02/24/2018-roundup-h2/">H2</a>: Preparing to Enable the Launcher Process by Default.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/01/04/2018-roundup-q2-part2/">2018 Roundup: Q2, Part 2 - Implementing a Skeletal Launcher Process</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2021-01-04T00:00:00-07:00" pubdate data-updated="true">Jan 4th, 2021</time>
        
           | <a href="/blog/2021/01/04/2018-roundup-q2-part2/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2021/01/04/2018-roundup-q2-part2/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>This is the third post in my &ldquo;2018 Roundup&rdquo; series. For an index of all entries, please see my
blog entry for <a href="https://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Q1</a>.</em></p>

<p>Yes, you are reading the dates correctly: I am posting this nearly two years after I began this series.
I am trying to get caught up on documenting my past work!</p>

<p>One of the things I added to Firefox for Windows was a new process called the &ldquo;launcher process.&rdquo;
&ldquo;Bootstrap process&rdquo; would be a better name, but we already used the term &ldquo;bootstrap&rdquo;
for our XPCOM initialization code. Instead of overloading that term and adding potential confusion,
I opted for using &ldquo;launcher process&rdquo; instead.</p>

<p>The launcher process is intended to be the first process that runs when the user starts
Firefox. Its sole purpose is to create the &ldquo;real&rdquo; browser process in a suspended state, set various
attributes on the browser process, resume the browser process, and then self-terminate.</p>

<p>In <a title="Skeletal bootstrap process" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1454745">bug 1454745</a> I implemented an initial skeletal (and opt-in) implementation of the
launcher process.</p>

<p>This seems like pretty straightforward code, right? Na&iuml;vely, one could just rip a <code>CreateProcess</code>
sample off of MSDN and call it day. The actual launcher process implmentation is more complicated than
that, for reasons that I will outline in the following sections.</p>

<h3>Built into <code>firefox.exe</code></h3>

<p>I wanted the launcher process to exist as a special &ldquo;mode&rdquo; of <code>firefox.exe</code>, as opposed to a distinct
executable.</p>

<h3>Performance</h3>

<p>By definition, the launcher process lies on the critical path to browser startup. I needed to be very
conscious of how we affect overall browser startup time.</p>

<p>Since the launcher process is built into <code>firefox.exe</code>, I needed to examine that executable&rsquo;s existing
dependencies to ensure that it is not loading any dependent libraries that are not actually needed
by the launcher process. Other than the essential Win32 DLLs <code>kernel32.dll</code> and <code>advapi32.dll</code> (and their
dependencies), I did not want anything else to load. In particular, I wanted to avoid loading <code>user32.dll</code>
and/or <code>gdi32.dll</code>, as this would trigger the initialization of Windows&#8217; GUI facilities, which would be a
huge performance killer. For that reason, most browser-mode library dependencies of <code>firefox.exe</code>
are either delay-loaded or are explicitly loaded via <code>LoadLibrary</code>.</p>

<h3>Safe Mode</h3>

<p>We wanted the launcher process to both respect Firefox&rsquo;s safe mode, as well as alter its behaviour
as necessary when safe mode is requested.</p>

<p>There are multiple mechanisms used by Firefox to detect safe mode. The launcher process detects
all of them except for one: Testing whether the user is holding the shift key. Retrieving keyboard
state would trigger loading of <code>user32.dll</code>, which would harm performance as I described above.</p>

<p>This is not too severe an issue in practice: The browser process itself would still detect the
shift key. Furthermore, while the launcher process may in theory alter its behaviour depending on
whether or not safe mode is requested, none of its behaviour changes are significant enough to
materially affect the browser&rsquo;s ability to start in safe mode.</p>

<p>Also note that, for serious cases where the browser is repeatedly unable to start,
the browser triggers a restart in safe mode via environment variable, which <em>is</em> a mechanism that
the launcher process honours.</p>

<h3>Testing and Automation</h3>

<p>We wanted the launcher process to behave well with respect to automated testing.</p>

<p>The skeletal launcher process that I landed in Q2 included code to pass its console handles
on to the browser process, but there was more work necessary to completely handle this case.
These capabilities were not yet an issue because the launcher process was opt-in at the time.</p>

<h3>Error Recovery</h3>

<p>We wanted the launcher process to gracefully handle failures even though, also by definition, it does not
have access to facilities that internal Gecko code has, such as preferences and the crash reporter.</p>

<p>The skeletal launcher process that I landed in Q2 did not yet utilize any special error handling
code, but this was also not yet an issue because the launcher process was opt-in at this point.</p>

<h3>Next Time</h3>

<p>Thanks for reading! Coming up in <a href="https://dblohm7.ca/blog/2021/01/05/2018-roundup-q2-part3/">Q2, Part 3</a>: Fleshing Out the Launcher Process</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/09/30/coming-around-full-circle/">Coming Around Full Circle</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2019-09-30T00:00:00-06:00" pubdate data-updated="true">Sep 30th, 2019</time>
        
           | <a href="/blog/2019/09/30/coming-around-full-circle/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2019/09/30/coming-around-full-circle/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>One thing about me that most Mozillians don&rsquo;t know is that, when I first applied to work at MoCo,
I had applied to work on the mobile platform. When all was said and done, it was decided at the time
that I would be a better fit for an opening on Taras Glek&rsquo;s platform performance team.</p>

<p>My first day at Mozilla was October 15, 2012 &mdash; I will be celebrating my seventh anniversary at MoCo in
just a couple short weeks! Some people with similar tenures have suggested to me that we are now
&ldquo;old guard,&rdquo; but I&rsquo;m not sure that I feel that way! Anyway, I digress.</p>

<p>The platform performance team eventually evolved into a desktop-focused performance team by late 2013.
By the end of 2015 I had decided that it was time for a change, and by March 2016 I had moved over to
work for Jim Mathies, focusing on Gecko integration with Windows. I ended up spending the next twenty
or so months helping the accessibility team port their Windows implementation over to multiprocess.</p>

<p>Once Firefox Quantum 57 hit the streets, I scoped out and provided technical leadership for the
InjectEject project, whose objective was to tackle some of the root problems with DLL injection that
were causing us grief in Windows-land.</p>

<p>I am proud to say that, over the past three years on Jim&rsquo;s team, I have done the best work of my career.
I&rsquo;d like to thank Brad Lassey (now at Google) for his willingness to bring me over to his group, as well as
Jim, and David Bolter (a11y manager at the time) for their confidence in me. As somebody who had spent most
of his adult life having no confidence in his work whatsoever, their willingness to entrust me with
taking on those risks and responsibilities made an enormous difference in my self esteem and my
professional life.</p>

<p>Over the course of H1 2019, I began to feel restless again. I knew it was time for another change. What
I did not expect was that the agent of that change would be James Willcox, aka Snorp. In Whistler, Snorp
planted the seed in my head that I might want to come over to work with him on GeckoView, within the
mobile group which David was now managing.</p>

<p>The timing seemed perfect, so I made the decision to move to GeckoView. I had to finish tying up some
loose ends with InjectEject, so all the various stakeholders agreed that I&rsquo;d move over at the end of Q3 2019.</p>

<p>Which brings me to this week, when I officially join the GeckoView team, working for Emily Toop. I find
it somewhat amusing that I am now joining the team that evolved from the team that I had originally applied
for back in 2012. I have truly come full circle in my career at Mozilla!</p>

<p>So, what&rsquo;s next?</p>

<ul>
<li><p>I have a couple of InjectEject bugs that are pretty much finished, but just need some polish and
code reviews before landing.</p></li>
<li><p>For the next month or two at least, I am going to continue to meet weekly with Jim to assist with
the transition as he ramps up new staff on the project.</p></li>
<li><p>I still plan to be the module owner for the Firefox Launcher Process and the MSCOM library, however most
day-to-day work will be done by others going forward;</p></li>
<li><p>I will continue to serve as the mozglue peer in charge of the DLL blocklist and DLL interceptor, with
the same caveat.</p></li>
</ul>


<p>Switching over to Android from Windows does not mean that I am leaving my Windows experience at the door; I
would like to continue to be a resource on that front, so I would encourage people to continue to ask me
for advice.</p>

<p>On the other hand, I am very much looking forward to stepping back into the mobile space. My first crack at
mobile was as an intern back in 2003, when I was working with some code that had to run on PalmOS 3.0! I have not
touched Android since I shipped a couple of utility apps back in 2011, so I am looking forward to learning
more about what has changed. I am also looking forward to learning more about native development on Android,
which is something that I never really had a chance to try.</p>

<p>As they used to say on Monty Python&rsquo;s Flying Circus, &ldquo;And now for something completely different!&rdquo;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/01/23/2018-roundup-q2-part1/">2018 Roundup: Q2, Part 1 - Refactoring the DLL Interceptor</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2019-01-23T00:00:00-07:00" pubdate data-updated="true">Jan 23rd, 2019</time>
        
           | <a href="/blog/2019/01/23/2018-roundup-q2-part1/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>This is the second post in my &ldquo;2018 Roundup&rdquo; series. For an index of all entries, please see my
blog entry for <a href="https://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Q1</a>.</em></p>

<p>As I have alluded to <a href="https://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time/">previously</a>,
Gecko includes a Detours-style API hooking mechanism for Windows. In Gecko, this code is referred to
as the &ldquo;DLL Interceptor.&rdquo; We use the DLL interceptor to instrument various functions within our own
processes. As a prerequisite for future DLL injection mitigations, I needed to spend a good chunk of
Q2 refactoring this code. While I was in there, I took the opportunity to improve the interceptor&rsquo;s
memory efficiency, thus benefitting the Fission MemShrink project. [<em>When these changes landed, we were
not yet tracking the memory savings, but I will include a rough estimate <a href="#vmsharing">later</a> in this post.</em>]</p>

<h3>A Brief Overview of Detours-style API Hooking</h3>

<p>While many distinct function hooking techniques are used in the Windows ecosystem, the Detours-style
hook is one of the most effective and most popular. While I am not going to go into too many specifics
here, I&rsquo;d like to offer a quick overview. In this description, &ldquo;target&rdquo; is the function being hooked.</p>

<p>Here is what happens when a function is detoured:</p>

<ol>
<li><p>Allocate a chunk of memory to serve as a &ldquo;trampoline.&rdquo; We must be able to adjust the protection
attributes on that memory.</p></li>
<li><p>Disassemble enough of the target to make room for a <code>jmp</code> instruction. On 32-bit x86 processors,
this requires 5 bytes. x86-64 is more complicated, but generally, to <code>jmp</code> to an absolute address, we
try to make room for 13 bytes.</p></li>
<li><p>Copy the instructions from step 2 over to the trampoline.</p></li>
<li><p>At the beginning of the target function, write a <code>jmp</code> to the hook function.</p></li>
<li><p>Append additional instructions to the trampoline that, when executed, will cause the processor to
jump back to the first valid instruction after the <code>jmp</code> written in step 4.</p></li>
<li><p>If the hook function wants to pass control on to the original target function, it calls the
trampoline.</p></li>
</ol>


<p>Note that these steps don&rsquo;t occur <em>exactly</em> in the order specified above; I selected the above ordering
in an effort to simplify my description.</p>

<p>Here is my attempt at visualizing the control flow of a detoured function on x86-64:</p>

<p><img src="https://dblohm7.ca/images/detours_hook.svg"></p>

<h3>Refactoring</h3>

<p>Previously, the DLL interceptor relied on directly manipulating pointers in order to read and write the
various instructions involved in the hook. In <a title="Parameterize memory operations in WindowsDllInterceptor" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1432653">bug 1432653</a> I changed things so that the memory
operations are parameterized based on two orthogonal concepts:</p>

<ul>
<li>In-process vs out-of-process memory access: I wanted to be able to abstract reads and writes such
that we could optionally set a hook in another process from our own.</li>
<li>Virtual memory allocation scheme: I wanted to be able to change how trampoline memory was allocated.
Previously, each instance of <code>WindowsDllInterceptor</code> allocated its own page of memory for trampolines,
but each instance also typically only sets one or two hooks. This means that most of the 4KiB page
was unused. Furthermore, since Windows allocates blocks of pages on a 64KiB boundary, this wasted a
lot of precious virtual address space in our 32-bit builds.</li>
</ul>


<p>By refactoring and parameterizing these operations, we ended up with the following combinations:</p>

<ul>
<li>In-process memory access, each <code>WindowsDllInterceptor</code> instance receives its own trampoline space;</li>
<li>In-process memory access, all <code>WindowsDllInterceptor</code> instances within a module <em>share</em> trampoline space;</li>
<li>Out-of-process memory access, each <code>WindowsDllInterceptor</code> instance receives its own trampoline space;</li>
<li>Out-of-process memory access, all <code>WindowsDllInterceptor</code> instances within a module share trampoline space (currently
not implemented as this option is not particularly useful at the moment).</li>
</ul>


<p>Instead of directly manipulating pointers, we now use instances of <code>ReadOnlyTargetFunction</code>,
<code>WritableTargetFunction</code>, and <code>Trampoline</code> to manipulate our code/data. Those classes in turn use the
memory management and virtual memory allocation policies to perform the actual reading and writing.</p>

<h3>Memory Management Policies</h3>

<p>The interceptor now supports two policies, <code>MMPolicyInProcess</code> and <code>MMPolicyOutOfProcess</code>. Each policy
must implement the following memory operations:</p>

<ul>
<li>Read</li>
<li>Write</li>
<li>Change protection attributes</li>
<li>Reserve trampoline space</li>
<li>Commit trampoline space</li>
</ul>


<p><code>MMPolicyInProcess</code> is implemented using <code>memcpy</code> for read and write, <code>VirtualProtect</code>
for protection attribute changes, and <code>VirtualAlloc</code> for reserving and committing trampoline space.</p>

<p><code>MMPolicyOutOfProcess</code> uses <code>ReadProcessMemory</code> and <code>WriteProcessMemory</code> for read and write. As a perf
optimization, we try to batch reads and writes together to reduce the system call traffic. We obviously
use <code>VirtualProtectEx</code> to adjust protection attributes in the other process.</p>

<p>Out-of-process trampoline reservation and commitment, however, is a bit different and is worth a
separate call-out. We allocate trampoline space using shared memory. It is mapped into the local
process with read+write permissions using <code>MapViewOfFile</code>. The memory is mapped into the remote process
as read+execute using some code that I wrote in <a title="Add out-of-process memory access policies to DLL interceptor" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1451511">bug 1451511</a> that either uses <code>NtMapViewOfSection</code> or
<code>MapViewOfFile2</code>, depending on availability. Individual pages from those chunks are then committed via
<code>VirtualAlloc</code> in the local process and <code>VirtualAllocEx</code> in the remote process. This scheme enables
us to read and write to trampoline memory directly, without needing to do cross-process reads and writes!</p>

<h3>VM Sharing Policies</h3>

<p>The code for these policies is a lot simpler than the code for the memory management policies. We now
have <code>VMSharingPolicyUnique</code> and <code>VMSharingPolicyShared</code>. Each of these policies must implement the
following operations:</p>

<ul>
<li>Reserve space for up to <em>N</em> trampolines of size <em>K</em>;</li>
<li>Obtain a <code>Trampoline</code> object for the next available <em>K</em>-byte trampoline slot;</li>
<li>Return an iterable collection of all extant trampolines.</li>
</ul>


<p><code>VMSharingPolicyShared</code> is actually implemented by delegating to a <code>static</code> instance of
<code>VMSharingPolicyUnique</code>.</p>

<h3>Implications of Refactoring</h3>

<p>To determine the performance implications, I added timings to our DLL Interceptor unit test. I was
very happy to see that, despite the additional layers of abstraction, the C++ compiler&rsquo;s optimizer was
doing its job: There was no performance impact whatsoever!</p>

<p><a name="vmsharing"></a>Once the refactoring was complete, I switched the default VM Sharing Policy for <code>WindowsDllInterceptor</code>
over to <code>VMSharingPolicyShared</code> in <a title="DLL interceptors should share trampoline VM" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1451524">bug 1451524</a>.</p>

<p>Browsing today&rsquo;s <code>mozilla-central</code> tip, I count 14 locations where we instantiate interceptors inside
<code>xul.dll</code>. Given that not all interceptors are necessarily instantiated at once, I am now offering a
worst-case back-of-the-napkin estimate of the memory savings:</p>

<ul>
<li>Each interceptor would likely be consuming 4KiB (most of which is unused) of committed VM. Due to
Windows&#8217; 64 KiB allocation guanularity, each interceptor would be leaving a further 60KiB
of address space in a free but unusable state. Assuming all 14 interceptors were actually instantiated,
they would thus consume a combined 56KiB of committed VM and 840KiB of free but unusable address space.</li>
<li>By sharing trampoline VM, the interceptors would consume only 4KiB combined and waste only 60KiB of
address space, thus yielding savings of 52KiB in committed memory and 780KiB in addressable memory.</li>
</ul>


<h3>Oh, and One More Thing</h3>

<p>Another problem that I discovered during this refactoring was <a title="Repeated failed function hook attempts cause exhaustion of interceptor trampoline space" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1459335">bug 1459335</a>. It turns out that some
of the interceptor&rsquo;s callers were not distinguishing between &ldquo;I have not set this hook yet&rdquo; and &ldquo;I
attempted to set this hook but it failed&rdquo; scenarios. Across several call sites, I discovered that
our code would repeatedly retry to set hooks even when they had previously failed, causing leakage
of trampoline space!</p>

<p>To fix this, I modified the interceptor&rsquo;s interface so that we use one-time initialization APIs to
set hooks; since landing this bug, it is no longer possible for clients of the DLL interceptor to
set a hook that had previously failed to be set.</p>

<p>Quantifying the memory costs of this bug is&hellip; non-trivial, but it suffices to say that fixing
this bug probably resulted in the savings of at least a few hundred KiB in committed VM on
affected machines.</p>

<p>That&rsquo;s it for today&rsquo;s post, folks! Thanks for reading! Coming up in <a href="https://dblohm7.ca/blog/2021/01/04/2018-roundup-q2-part2/">Q2, Part 2</a>: Implementing a Skeletal Launcher Process</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/01/18/2018-roundup-q1/">2018 Roundup: Q1 - Learning More About DLLs Injected Into Firefox</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2019-01-18T00:00:00-07:00" pubdate data-updated="true">Jan 18th, 2019</time>
        
           | <a href="/blog/2019/01/18/2018-roundup-q1/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I had a very busy 2018. So busy, in fact, that I have not been able to devote any time to actually
discussing what I worked on! I had intended to write these posts during the end of December, but a
hardware failure delayed that until the new year. Alas, here we are in 2019, and I am going to do a
series of retrospectives on last year&rsquo;s work, broken up by quarter.</p>

<p>Here is an index of all the entries in this series:</p>

<ul>
<li><a href="https://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Q1 - Overview, Learning More About DLLs Injected into Firefox</a> (this post)</li>
<li><a href="https://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">Q2, Part 1 - Refactoring the DLL Interceptor</a></li>
<li><a href="https://dblohm7.ca/blog/2021/01/04/2018-roundup-q2-part2/">Q2, Part 2 - Implementing a Skeletal Launcher Process</a></li>
<li><a href="https://dblohm7.ca/blog/2021/01/05/2018-roundup-q2-part3/">Q2, Part 3 - Fleshing Out the Launcher Process</a></li>
<li><a href="https://dblohm7.ca/blog/2021/02/24/2018-roundup-h2/">H2 - Preparing to Enable the Launcher Process by Default</a></li>
</ul>


<h2>Overview</h2>

<p>The general theme of my work in 2018 was dealing with the DLL injection problem: On Windows,
third parties love to forcibly load their DLLs into other processes &mdash; web browsers in particular,
thus making Firefox a primary target.</p>

<p>Many of these libraries tend to alter Firefox processes in ways that hurt the stability and/or performance
of our code; many chemspill releases have gone out over the years to deal with these problems. While I
could rant for hours over this, the fact is that DLL injection is rampant in the ecosystem of Windows
desktop applications and is not going to disappear any time soon. In the meantime, we need to be able
to deal with it.</p>

<p>Some astute readers might be ready to send me an email or post a comment about how ignorant I am about
the new(-ish) process mitigation policies that are available in newer versions of Windows. While those
features are definitely useful, they are not panaceas:</p>

<ul>
<li>We cannot turn on the &ldquo;Extension Point Disable&rdquo; policy for users of assistive technologies; screen
readers rely heavily on DLL injection using <code>SetWindowsHookEx</code> and <code>SetWinEventHook</code>, both of which
are covered by this policy;</li>
<li>We could enable the &ldquo;Microsoft Binary Signature&rdquo; policy, however that requires us to load our own
DLLs first before enabling; once that happens, it is often already too late: other DLLs have already
injected themselves by the time we are able to activate this policy. (Note that this could easily be
solved if this policy were augmented to also permit loading of any DLL signed by the same organization
as that of the process&rsquo;s executable binary, but Microsoft seems to be unwilling to do this.)</li>
<li>The above mitigations are not universally available. They do not help us on Windows 7.</li>
</ul>


<p>For me, Q1 2018 was all about gathering better data about injected DLLs.</p>

<h2>Learning More About DLLs Injected into Firefox</h2>

<p>One of our major pain points over the years of dealing with injected DLLs has been that the vendor of
the DLL is not always apparent to us. In general, our crash reports and telemetry pings only include
the leaf name of the various DLLs on a user&rsquo;s system. This is intentional on our part: we want to
preserve user privacy. On the other hand, this severely limits our ability to determine which party
is responsible for a particular DLL.</p>

<p>One avenue for obtaining this information is to look at any digital signature that is embedded in the
DLL. By examining the certificate that was used to sign the binary, we can extract the organization
of the cert&rsquo;s owner and include that with our crash reports and telemetry.</p>

<p>In <a title="Include authenticode cert information with crash reports" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1430857">bug 1430857</a> I wrote a bunch of code that enables us to extract that information from signed
binaries using the Windows Authenticode APIs. Originally, in that bug, all of that signature extraction
work happened from within the browser itself, while it was running: It would gather the cert information
on a background thread while the browser was running, and include those annotations in a subsequent
crash dump, should such a thing occur.</p>

<p>After some reflection, I realized that I was not gathering annotations in the right place. As an example,
what if an injected DLL were to trigger a crash before the background thread had a chance to grab
that DLL&rsquo;s cert information?</p>

<p>I realized that the best place to gather this information was in a post-processing step after the
crash dump had been generated, and in fact we already had the right mechanism for doing so: the
<code>minidump-analyzer</code> program was already doing post-processing on Firefox crash dumps before sending
them back to Mozilla. I moved the signature extraction and crash annotation code out of Gecko and
into the analyzer in <a title="Cert annotation performance and reliability improvements" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1436845">bug 1436845</a>.</p>

<p>(As an aside, while working on the <code>minidump-analyzer</code>, I found some problems with how it handled
command line arguments: it was assuming that <code>main</code> passes its <code>argv</code> as UTF-8, which is not true on
Windows. I fixed those issues in <a title="Minidump analyzer assuming utf-8 command-line arguments on Windows" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1437156">bug 1437156</a>.)</p>

<p>In <a title="Add module cert info to modules ping" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1434489">bug 1434489</a> I also ended up adding this information to the &ldquo;modules ping&rdquo; that we have in
telemetry; IIRC this ping is only sent weekly. When the modules ping is requested, we gather the
module cert info asynchronously on a background thread.</p>

<p>Finally, I had to modify Socorro (the back-end for <a href="https://crash-stats.mozilla.com">crash-stats</a>) to
be able to understand the signature annotations and be able to display them via <a title="Add module cert info to crash report "Modules" tab" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1434495">bug 1434495</a>. This
required two commits: one to modify the Socorro stackwalker to merge the module signature information
into the full crash report, and another to add a &ldquo;Signed By&rdquo; column to every report&rsquo;s &ldquo;Modules&rdquo; tab to
display the signature information (Note that this column is only present when at least one module in
a particular crash report contains signature information).</p>

<p>The end result was very satisfying: Most of the injected DLLs in our Windows crash reports are signed,
so it is now much easier to identify their vendors!</p>

<p>This project was very satisifying for me in many ways: First of all, surfacing this information was an
itch that I had been wanting to scratch for quite some time. Secondly, this really was a &ldquo;full stack&rdquo;
project, touching everything from extracting signature info from binaries using C++, all the way up to
writing some back-end code in Python and a little touch of front-end stuff to surface the data in the
web app.</p>

<p>Note that, while this project focused on Windows because of the severity of the library injection
problem on that platform, it would be easy enough to reuse most of this code for macOS builds as well;
the only major work for the latter case would be for extracting signature information from a dylib.
This is not currently a priority for us, though.</p>

<p>Thanks for reading! Coming up in <a href="https://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">Q2</a>:
Refactoring the DLL Interceptor!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/11/16/legacy-firefox-extensions-and-userspace/">Legacy Firefox Extensions and &#8220;Userspace&#8221;</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2017-11-16T00:00:00-07:00" pubdate data-updated="true">Nov 16th, 2017</time>
        
           | <a href="/blog/2017/11/16/legacy-firefox-extensions-and-userspace/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2017/11/16/legacy-firefox-extensions-and-userspace/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This week&rsquo;s release of Firefox Quantum has prompted all kinds of feedback, both
positive and negative. That is not surprising to anybody &mdash; any software that
has a large number of users is going to be a topic for discussion, especially
when the release in question is undoubtedly a watershed.</p>

<p>While I have <a href="https://dblohm7.ca/blog/2015/08/30/on-webextensions/">previously</a>
blogged about the transition to WebExtensions, now that we have actually passed
through the cutoff for legacy extensions, I have decided to add some new
commentary on the subject.</p>

<p>One analogy that has been used in the discussion of the extension ecosystem is
that of kernelspace and userspace. The crux of the analogy is that Gecko is
equivalent to an operating system kernel, and thus extensions are the user-mode
programs that run atop that kernel. The argument then follows that Mozilla&rsquo;s
deprecation and removal of legacy extension capabilities is akin to &ldquo;breaking&rdquo;
userspace. [<em>Some people who say this are using the same tone as Linus does
whenever he eviscerates Linux developers who break userspace, which is neither
productive nor welcomed by anyone, but I digress.</em>] Unfortunately, that analogy
simply does not map to the legacy extension model.</p>

<h2>Legacy Extensions as Kernel Modules</h2>

<p>The most significant problem with the userspace analogy is that legacy extensions
effectively meld with Gecko and become part of Gecko itself. If we accept the
premise that Gecko is like a monolithic OS kernel, then we must also accept that
the analogical equivalent of loading arbitrary code into that kernel, is the
kernel module. Such components are loaded into the kernel and effectively become
part of it. Their code runs with full privileges. They break whenever
significant changes are made to the kernel itself.</p>

<p>Sound familiar?</p>

<p>Legacy extensions were akin to kernel modules. When there is no abstraction,
there can be no such thing as userspace. This is precisely the problem that
WebExtensions solves!</p>

<h2>Building Out a Legacy API</h2>

<p>Maybe somebody out there is thinking, &ldquo;well what if you took all the APIs that
legacy extensions used, turned that into a &lsquo;userspace,&rsquo; and then just left that
part alone?&rdquo;</p>

<p>Which APIs? Where do we draw the line? Do we check the code coverage for every
legacy addon in AMO and use that to determine what to include?</p>

<p>Remember, there was no abstraction; installed legacy addons are fused to Gecko.
If we pledge not to touch anything that legacy addons might touch, then we
cannot touch anything at all.</p>

<p>Where do we go from here? Freeze an old version of Gecko and host an entire copy
of it inside web content? Compile it to WebAssembly? [<em>Oh God, what have I done?</em>]</p>

<p>If <em>that&rsquo;s</em> not a maintenance burden, I don&rsquo;t know what is!</p>

<h2>A Kernel Analogy for WebExtensions</h2>

<p>Another problem with the legacy-extensions-as-userspace analogy is that it leaves
awkward room for web content, whose API is abstract and well-defined. I do not
think that it is appropriate to consider web content to be equivalent to a
sandboxed application, as sandboxed applications use the same (albeit restricted)
API as normal applications. I would suggest that the presence of WebExtensions
gives us a better kernel analogy:</p>

<ul>
<li>Gecko is the kernel;</li>
<li>WebExtensions are privileged user applications;</li>
<li>Web content runs as unprivileged user applications.</li>
</ul>


<h2>In Conclusion</h2>

<p>Declaring that legacy extensions are userspace does not make them so. The way that
the technology actually worked defies the abstract model that the analogy
attempts to impose upon it. On the other hand, we can use the failure of that
analogy to explain why WebExtensions are important and construct an extension
ecosystem that <em>does</em> fit with that analogy.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/07/17/win32-gotchas/">Win32 Gotchas</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2017-07-17T00:00:00-06:00" pubdate data-updated="true">Jul 17th, 2017</time>
        
           | <a href="/blog/2017/07/17/win32-gotchas/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2017/07/17/win32-gotchas/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>For the second time since I have been at Mozilla I have encountered a situation
where hooks are called for notifications of a newly created window, but that
window has not yet been initialized properly, causing the hooks to behave badly.</p>

<p>The first time was inside our window neutering code in IPC, while the second
time was in our accessibility code.</p>

<p>Every time I have seen this, there is code that follows this pattern:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">HWND</span> <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">hwnd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Do some follow-up initialization to hwnd (Using SetProp as an example):</span>
</span><span class='line'>  <span class="n">SetProp</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This seems innocuous enough, right?</p>

<p>The problem is that <code>CreateWindowEx</code> calls hooks. If those hooks then try to do
something like <code>GetProp(hwnd, "Foo")</code>, that call is going to fail because the
&ldquo;Foo&rdquo; prop has not yet been set.</p>

<p>The key takeaway from this is that, if you are creating a new window, you must
do any follow-up initialization from within your window proc&rsquo;s <code>WM_CREATE</code>
handler. This will guarantee that your window&rsquo;s initialization will have
completed before any hooks are called.</p>

<p>You might be thinking, &ldquo;But I don&rsquo;t set any hooks!&rdquo; While this may be true, you
must not forget about hooks set by third-party code.</p>

<p>&ldquo;But those hooks won&rsquo;t know anything about my program&rsquo;s internals, right?&rdquo;</p>

<p>Perhaps, perhaps not. But when those hooks fire, they give third-party software
the opportunity to run. In some cases, those hooks might even cause the thread
to <em>reenter your own code</em>. Your window had better be completely initialized
when this happens!</p>

<p>In the case of my latest discovery of this issue in <a title="Window emulation needs to SetProp inside WM_CREATE" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1380471">bug 1380471</a>, I made it
possible to use a C++11 lambda to simplify this pattern.</p>

<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680.aspx"><code>CreateWindowEx</code></a>
accepts a <code>lpParam</code> parameter which is then passed to the <code>WM_CREATE</code> handler
as the <code>lpCreateParams</code> member of a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632603.aspx"><code>CREATESTRUCT</code></a>.</p>

<p>By setting <code>lpParam</code> to a pointer to a <code>std::function&lt;void(HWND)&gt;</code>, we may then
supply any callable that we wish for follow-up window initialization.</p>

<p>Using the previous code sample as a baseline, this allows me to revise the code
to safely set a property like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">HWND</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">onCreate</span><span class="p">([](</span><span class="n">HWND</span> <span class="n">aHwnd</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">SetProp</span><span class="p">(</span><span class="n">aHwnd</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">HWND</span> <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">onCreate</span><span class="p">);</span>
</span><span class='line'><span class="c1">// At this point is already too late to further initialize hwnd!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that since <code>lpParam</code> is always passed during <code>WM_CREATE</code>, which always fires
before <code>CreateWindowEx</code> returns, it is safe for <code>onCreate</code> to live on the stack.</p>

<p>I liked this solution for the a11y case because it preserved the locality of
the initialization code within the function that called <code>CreateWindowEx</code>; the
window proc for this window is implemented in another source file and the
follow-up initialization depends on the context surrounding the <code>CreateWindowEx</code>
call.</p>

<p>Speaking of window procs, here is how that window&rsquo;s <code>WM_CREATE</code> handler invokes
the callable:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">uMsg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">WM_CREATE</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">createStruct</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CREATESTRUCT</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">lParam</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">createProc</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">HWND</span><span class="p">)</span><span class="o">&gt;*&gt;</span><span class="p">(</span>
</span><span class='line'>      <span class="n">createStruct</span><span class="o">-&gt;</span><span class="n">lpCreateParams</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">createProc</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">createProc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">(</span><span class="o">*</span><span class="n">createProc</span><span class="p">)(</span><span class="n">hwnd</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>TL;DR:</strong> If you see a pattern where further initialization work is being done
on an <code>HWND</code> after a <code>CreateWindowEx</code> call, move that initialization code to your
window&rsquo;s <code>WM_CREATE</code> handler instead.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/06/12/why-i-prefer-using-critical-sections-for-mutexes-in-windows-nightly-builds/">Why I Prefer Using CRITICAL_SECTIONs for Mutexes in Windows Nightly Builds</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2017-06-12T00:00:00-06:00" pubdate data-updated="true">Jun 12th, 2017</time>
        
           | <a href="/blog/2017/06/12/why-i-prefer-using-critical-sections-for-mutexes-in-windows-nightly-builds/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2017/06/12/why-i-prefer-using-critical-sections-for-mutexes-in-windows-nightly-builds/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In the past I have argued that our Nightly builds, both debug and release, should
use <code>CRITICAL_SECTION</code>s (with full debug info) for our implementation of
<code>mozilla::Mutex</code>. I&rsquo;d like to illustrate some reasons why this is so useful.</p>

<h2>They enable more utility in WinDbg extensions</h2>

<p>Every time you initialize a <code>CRITICAL_SECTION</code>, Windows inserts the CS&rsquo;s
debug info into a process-wide linked list. This enables their discovery by
the Windows debugging engine, and makes the <code>!cs</code>, <code>!critsec</code>, and <code>!locks</code>
commands more useful.</p>

<h2>They enable profiling of their initialization and acquisition</h2>

<p>When the &ldquo;Create user mode stack trace database&rdquo; gflag is enabled, Windows
records the call stack of the thread that called <code>InitializeCriticalSection</code>
on that CS. Windows also records the call stack of the owning thread once
it has acquired the CS. This can be very useful for debugging deadlocks.</p>

<h2>They track their contention counts</h2>

<p>Since every CS has been placed in a process-wide linked list, we may now ask
the debugger to dump statistics about every live CS in the process. In
particular, we can ask the debugger to output the contention counts for each
CS in the process. After running a workload against Nightly, we may then take
the contention output, sort it descendingly, and be able to determine which
<code>CRITICAL_SECTION</code>s are the most contended in the process.</p>

<p>We may then want to more closely inspect the hottest CSes to determine whether
there is anything that we can do to reduce contention and all of the extra
context switching that entails.</p>

<h2>In Summary</h2>

<p>When we use <code>SRWLOCK</code>s or initialize our <code>CRITICAL_SECTION</code>s with the
<code>CRITICAL_SECTION_NO_DEBUG_INFO</code> flag, we are denying ourselves access to this
information. That&rsquo;s fine on release builds, but on Nightly I think it is worth
having around. While I realize that most Mozilla developers have not used this
until now (otherwise I would not be writing this blog post), this rich debugger
info is one of those things that you do not miss until you do not have it.</p>

<p>For further reading about critical section debug info, check out
<a href="https://web.archive.org/web/20150419055323/https://msdn.microsoft.com/en-us/magazine/cc164040.aspx">this</a>
archived article from MSDN Magazine.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/03/01/2019-roundup-part-1/">2019 Roundup: Part 1 - Porting the DLL Interceptor to AArch64</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/02/24/2018-roundup-h2/">2018 Roundup: H2 - Preparing to Enable the Launcher Process by Default</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/01/05/2018-roundup-q2-part3/">2018 Roundup: Q2, Part 3 - Fleshing Out the Launcher Process</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/01/04/2018-roundup-q2-part2/">2018 Roundup: Q2, Part 2 - Implementing a Skeletal Launcher Process</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/09/30/coming-around-full-circle/">Coming Around Full Circle</a>
      </li>
    
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - Aaron Klotz -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dblohm7';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
