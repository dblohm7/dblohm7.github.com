
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Aaron Klotz at Mozilla</title>
  <meta name="author" content="Aaron Klotz">

  
  <meta name="description" content="I had a very busy 2018. So busy, in fact, that I have not been able to devote any time to actually
discussing what I worked on! I had intended to &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://dblohm7.ca/posts/3">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Aaron Klotz at Mozilla" type="application/atom+xml">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  

<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-36293908-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-36293908-1');
  </script>


  <link href="https://dblohm7.ca/favicon.svg" rel="icon" sizes="any" type="image/svg+xml">
  <link href="https://dblohm7.ca/favicon.gif" rel="icon">
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Aaron Klotz at Mozilla</a></h1>
  
    <h2>My adventures as a member of Mozilla&#8217;s GeckoView Team</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:dblohm7.ca" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/01/18/2018-roundup-q1/">2018 Roundup: Q1 - Learning More About DLLs Injected Into Firefox</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2019-01-18T00:00:00-07:00" pubdate data-updated="true">Jan 18th, 2019</time>
        
           | <a href="/blog/2019/01/18/2018-roundup-q1/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I had a very busy 2018. So busy, in fact, that I have not been able to devote any time to actually
discussing what I worked on! I had intended to write these posts during the end of December, but a
hardware failure delayed that until the new year. Alas, here we are in 2019, and I am going to do a
series of retrospectives on last year&rsquo;s work, broken up by quarter.</p>

<p>Here is an index of all the entries in this series:</p>

<ul>
<li><a href="https://dblohm7.ca/blog/2019/01/18/2018-roundup-q1/">Q1 - Overview, Learning More About DLLs Injected into Firefox</a> (this post)</li>
<li><a href="https://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">Q2, Part 1 - Refactoring the DLL Interceptor</a></li>
<li><a href="https://dblohm7.ca/blog/2021/01/04/2018-roundup-q2-part2/">Q2, Part 2 - Implementing a Skeletal Launcher Process</a></li>
<li><a href="https://dblohm7.ca/blog/2021/01/05/2018-roundup-q2-part3/">Q2, Part 3 - Fleshing Out the Launcher Process</a></li>
<li><a href="https://dblohm7.ca/blog/2021/02/24/2018-roundup-h2/">H2 - Preparing to Enable the Launcher Process by Default</a></li>
</ul>


<h2>Overview</h2>

<p>The general theme of my work in 2018 was dealing with the DLL injection problem: On Windows,
third parties love to forcibly load their DLLs into other processes &mdash; web browsers in particular,
thus making Firefox a primary target.</p>

<p>Many of these libraries tend to alter Firefox processes in ways that hurt the stability and/or performance
of our code; many chemspill releases have gone out over the years to deal with these problems. While I
could rant for hours over this, the fact is that DLL injection is rampant in the ecosystem of Windows
desktop applications and is not going to disappear any time soon. In the meantime, we need to be able
to deal with it.</p>

<p>Some astute readers might be ready to send me an email or post a comment about how ignorant I am about
the new(-ish) process mitigation policies that are available in newer versions of Windows. While those
features are definitely useful, they are not panaceas:</p>

<ul>
<li>We cannot turn on the &ldquo;Extension Point Disable&rdquo; policy for users of assistive technologies; screen
readers rely heavily on DLL injection using <code>SetWindowsHookEx</code> and <code>SetWinEventHook</code>, both of which
are covered by this policy;</li>
<li>We could enable the &ldquo;Microsoft Binary Signature&rdquo; policy, however that requires us to load our own
DLLs first before enabling; once that happens, it is often already too late: other DLLs have already
injected themselves by the time we are able to activate this policy. (Note that this could easily be
solved if this policy were augmented to also permit loading of any DLL signed by the same organization
as that of the process&rsquo;s executable binary, but Microsoft seems to be unwilling to do this.)</li>
<li>The above mitigations are not universally available. They do not help us on Windows 7.</li>
</ul>


<p>For me, Q1 2018 was all about gathering better data about injected DLLs.</p>

<h2>Learning More About DLLs Injected into Firefox</h2>

<p>One of our major pain points over the years of dealing with injected DLLs has been that the vendor of
the DLL is not always apparent to us. In general, our crash reports and telemetry pings only include
the leaf name of the various DLLs on a user&rsquo;s system. This is intentional on our part: we want to
preserve user privacy. On the other hand, this severely limits our ability to determine which party
is responsible for a particular DLL.</p>

<p>One avenue for obtaining this information is to look at any digital signature that is embedded in the
DLL. By examining the certificate that was used to sign the binary, we can extract the organization
of the cert&rsquo;s owner and include that with our crash reports and telemetry.</p>

<p>In <a title="Include authenticode cert information with crash reports" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1430857">bug 1430857</a> I wrote a bunch of code that enables us to extract that information from signed
binaries using the Windows Authenticode APIs. Originally, in that bug, all of that signature extraction
work happened from within the browser itself, while it was running: It would gather the cert information
on a background thread while the browser was running, and include those annotations in a subsequent
crash dump, should such a thing occur.</p>

<p>After some reflection, I realized that I was not gathering annotations in the right place. As an example,
what if an injected DLL were to trigger a crash before the background thread had a chance to grab
that DLL&rsquo;s cert information?</p>

<p>I realized that the best place to gather this information was in a post-processing step after the
crash dump had been generated, and in fact we already had the right mechanism for doing so: the
<code>minidump-analyzer</code> program was already doing post-processing on Firefox crash dumps before sending
them back to Mozilla. I moved the signature extraction and crash annotation code out of Gecko and
into the analyzer in <a title="Cert annotation performance and reliability improvements" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1436845">bug 1436845</a>.</p>

<p>(As an aside, while working on the <code>minidump-analyzer</code>, I found some problems with how it handled
command line arguments: it was assuming that <code>main</code> passes its <code>argv</code> as UTF-8, which is not true on
Windows. I fixed those issues in <a title="Minidump analyzer assuming utf-8 command-line arguments on Windows" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1437156">bug 1437156</a>.)</p>

<p>In <a title="Add module cert info to modules ping" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1434489">bug 1434489</a> I also ended up adding this information to the &ldquo;modules ping&rdquo; that we have in
telemetry; IIRC this ping is only sent weekly. When the modules ping is requested, we gather the
module cert info asynchronously on a background thread.</p>

<p>Finally, I had to modify Socorro (the back-end for <a href="https://crash-stats.mozilla.com">crash-stats</a>) to
be able to understand the signature annotations and be able to display them via <a title="Add module cert info to crash report "Modules" tab" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1434495">bug 1434495</a>. This
required two commits: one to modify the Socorro stackwalker to merge the module signature information
into the full crash report, and another to add a &ldquo;Signed By&rdquo; column to every report&rsquo;s &ldquo;Modules&rdquo; tab to
display the signature information (Note that this column is only present when at least one module in
a particular crash report contains signature information).</p>

<p>The end result was very satisfying: Most of the injected DLLs in our Windows crash reports are signed,
so it is now much easier to identify their vendors!</p>

<p>This project was very satisifying for me in many ways: First of all, surfacing this information was an
itch that I had been wanting to scratch for quite some time. Secondly, this really was a &ldquo;full stack&rdquo;
project, touching everything from extracting signature info from binaries using C++, all the way up to
writing some back-end code in Python and a little touch of front-end stuff to surface the data in the
web app.</p>

<p>Note that, while this project focused on Windows because of the severity of the library injection
problem on that platform, it would be easy enough to reuse most of this code for macOS builds as well;
the only major work for the latter case would be for extracting signature information from a dylib.
This is not currently a priority for us, though.</p>

<p>Thanks for reading! Coming up in <a href="https://dblohm7.ca/blog/2019/01/23/2018-roundup-q2-part1/">Q2</a>:
Refactoring the DLL Interceptor!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/11/16/legacy-firefox-extensions-and-userspace/">Legacy Firefox Extensions and &#8220;Userspace&#8221;</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2017-11-16T00:00:00-07:00" pubdate data-updated="true">Nov 16th, 2017</time>
        
           | <a href="/blog/2017/11/16/legacy-firefox-extensions-and-userspace/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2017/11/16/legacy-firefox-extensions-and-userspace/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This week&rsquo;s release of Firefox Quantum has prompted all kinds of feedback, both
positive and negative. That is not surprising to anybody &mdash; any software that
has a large number of users is going to be a topic for discussion, especially
when the release in question is undoubtedly a watershed.</p>

<p>While I have <a href="https://dblohm7.ca/blog/2015/08/30/on-webextensions/">previously</a>
blogged about the transition to WebExtensions, now that we have actually passed
through the cutoff for legacy extensions, I have decided to add some new
commentary on the subject.</p>

<p>One analogy that has been used in the discussion of the extension ecosystem is
that of kernelspace and userspace. The crux of the analogy is that Gecko is
equivalent to an operating system kernel, and thus extensions are the user-mode
programs that run atop that kernel. The argument then follows that Mozilla&rsquo;s
deprecation and removal of legacy extension capabilities is akin to &ldquo;breaking&rdquo;
userspace. [<em>Some people who say this are using the same tone as Linus does
whenever he eviscerates Linux developers who break userspace, which is neither
productive nor welcomed by anyone, but I digress.</em>] Unfortunately, that analogy
simply does not map to the legacy extension model.</p>

<h2>Legacy Extensions as Kernel Modules</h2>

<p>The most significant problem with the userspace analogy is that legacy extensions
effectively meld with Gecko and become part of Gecko itself. If we accept the
premise that Gecko is like a monolithic OS kernel, then we must also accept that
the analogical equivalent of loading arbitrary code into that kernel, is the
kernel module. Such components are loaded into the kernel and effectively become
part of it. Their code runs with full privileges. They break whenever
significant changes are made to the kernel itself.</p>

<p>Sound familiar?</p>

<p>Legacy extensions were akin to kernel modules. When there is no abstraction,
there can be no such thing as userspace. This is precisely the problem that
WebExtensions solves!</p>

<h2>Building Out a Legacy API</h2>

<p>Maybe somebody out there is thinking, &ldquo;well what if you took all the APIs that
legacy extensions used, turned that into a &lsquo;userspace,&rsquo; and then just left that
part alone?&rdquo;</p>

<p>Which APIs? Where do we draw the line? Do we check the code coverage for every
legacy addon in AMO and use that to determine what to include?</p>

<p>Remember, there was no abstraction; installed legacy addons are fused to Gecko.
If we pledge not to touch anything that legacy addons might touch, then we
cannot touch anything at all.</p>

<p>Where do we go from here? Freeze an old version of Gecko and host an entire copy
of it inside web content? Compile it to WebAssembly? [<em>Oh God, what have I done?</em>]</p>

<p>If <em>that&rsquo;s</em> not a maintenance burden, I don&rsquo;t know what is!</p>

<h2>A Kernel Analogy for WebExtensions</h2>

<p>Another problem with the legacy-extensions-as-userspace analogy is that it leaves
awkward room for web content, whose API is abstract and well-defined. I do not
think that it is appropriate to consider web content to be equivalent to a
sandboxed application, as sandboxed applications use the same (albeit restricted)
API as normal applications. I would suggest that the presence of WebExtensions
gives us a better kernel analogy:</p>

<ul>
<li>Gecko is the kernel;</li>
<li>WebExtensions are privileged user applications;</li>
<li>Web content runs as unprivileged user applications.</li>
</ul>


<h2>In Conclusion</h2>

<p>Declaring that legacy extensions are userspace does not make them so. The way that
the technology actually worked defies the abstract model that the analogy
attempts to impose upon it. On the other hand, we can use the failure of that
analogy to explain why WebExtensions are important and construct an extension
ecosystem that <em>does</em> fit with that analogy.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/07/17/win32-gotchas/">Win32 Gotchas</a></h1>
    
    
      <p class="meta">
        






  



<time datetime="2017-07-17T00:00:00-06:00" pubdate data-updated="true">Jul 17th, 2017</time>
        
           | <a href="/blog/2017/07/17/win32-gotchas/#disqus_thread"
             data-disqus-identifier="http://dblohm7.ca/blog/2017/07/17/win32-gotchas/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>For the second time since I have been at Mozilla I have encountered a situation
where hooks are called for notifications of a newly created window, but that
window has not yet been initialized properly, causing the hooks to behave badly.</p>

<p>The first time was inside our window neutering code in IPC, while the second
time was in our accessibility code.</p>

<p>Every time I have seen this, there is code that follows this pattern:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">HWND</span> <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">hwnd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Do some follow-up initialization to hwnd (Using SetProp as an example):</span>
</span><span class='line'>  <span class="n">SetProp</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This seems innocuous enough, right?</p>

<p>The problem is that <code>CreateWindowEx</code> calls hooks. If those hooks then try to do
something like <code>GetProp(hwnd, "Foo")</code>, that call is going to fail because the
&ldquo;Foo&rdquo; prop has not yet been set.</p>

<p>The key takeaway from this is that, if you are creating a new window, you must
do any follow-up initialization from within your window proc&rsquo;s <code>WM_CREATE</code>
handler. This will guarantee that your window&rsquo;s initialization will have
completed before any hooks are called.</p>

<p>You might be thinking, &ldquo;But I don&rsquo;t set any hooks!&rdquo; While this may be true, you
must not forget about hooks set by third-party code.</p>

<p>&ldquo;But those hooks won&rsquo;t know anything about my program&rsquo;s internals, right?&rdquo;</p>

<p>Perhaps, perhaps not. But when those hooks fire, they give third-party software
the opportunity to run. In some cases, those hooks might even cause the thread
to <em>reenter your own code</em>. Your window had better be completely initialized
when this happens!</p>

<p>In the case of my latest discovery of this issue in <a title="Window emulation needs to SetProp inside WM_CREATE" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1380471">bug 1380471</a>, I made it
possible to use a C++11 lambda to simplify this pattern.</p>

<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680.aspx"><code>CreateWindowEx</code></a>
accepts a <code>lpParam</code> parameter which is then passed to the <code>WM_CREATE</code> handler
as the <code>lpCreateParams</code> member of a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632603.aspx"><code>CREATESTRUCT</code></a>.</p>

<p>By setting <code>lpParam</code> to a pointer to a <code>std::function&lt;void(HWND)&gt;</code>, we may then
supply any callable that we wish for follow-up window initialization.</p>

<p>Using the previous code sample as a baseline, this allows me to revise the code
to safely set a property like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">HWND</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">onCreate</span><span class="p">([](</span><span class="n">HWND</span> <span class="n">aHwnd</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">SetProp</span><span class="p">(</span><span class="n">aHwnd</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">HWND</span> <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">onCreate</span><span class="p">);</span>
</span><span class='line'><span class="c1">// At this point is already too late to further initialize hwnd!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that since <code>lpParam</code> is always passed during <code>WM_CREATE</code>, which always fires
before <code>CreateWindowEx</code> returns, it is safe for <code>onCreate</code> to live on the stack.</p>

<p>I liked this solution for the a11y case because it preserved the locality of
the initialization code within the function that called <code>CreateWindowEx</code>; the
window proc for this window is implemented in another source file and the
follow-up initialization depends on the context surrounding the <code>CreateWindowEx</code>
call.</p>

<p>Speaking of window procs, here is how that window&rsquo;s <code>WM_CREATE</code> handler invokes
the callable:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">uMsg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">WM_CREATE</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">createStruct</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CREATESTRUCT</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">lParam</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">createProc</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">HWND</span><span class="p">)</span><span class="o">&gt;*&gt;</span><span class="p">(</span>
</span><span class='line'>      <span class="n">createStruct</span><span class="o">-&gt;</span><span class="n">lpCreateParams</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">createProc</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">createProc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">(</span><span class="o">*</span><span class="n">createProc</span><span class="p">)(</span><span class="n">hwnd</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>TL;DR:</strong> If you see a pattern where further initialization work is being done
on an <code>HWND</code> after a <code>CreateWindowEx</code> call, move that initialization code to your
window&rsquo;s <code>WM_CREATE</code> handler instead.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/03/01/2019-roundup-part-1/">2019 Roundup: Part 1 - Porting the DLL Interceptor to AArch64</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/02/24/2018-roundup-h2/">2018 Roundup: H2 - Preparing to Enable the Launcher Process by Default</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/01/05/2018-roundup-q2-part3/">2018 Roundup: Q2, Part 3 - Fleshing Out the Launcher Process</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/01/04/2018-roundup-q2-part2/">2018 Roundup: Q2, Part 2 - Implementing a Skeletal Launcher Process</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/09/30/coming-around-full-circle/">Coming Around Full Circle</a>
      </li>
    
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - Aaron Klotz -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dblohm7';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
