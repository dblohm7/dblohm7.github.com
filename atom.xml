<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Aaron Klotz at Mozilla]]></title>
  <link href="http://dblohm7.ca/atom.xml" rel="self"/>
  <link href="http://dblohm7.ca/"/>
  <updated>2017-07-17T12:03:49-06:00</updated>
  <id>http://dblohm7.ca/</id>
  <author>
    <name><![CDATA[Aaron Klotz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Win32 Gotchas]]></title>
    <link href="http://dblohm7.ca/blog/2017/07/17/win32-gotchas/"/>
    <updated>2017-07-17T12:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2017/07/17/win32-gotchas</id>
    <content type="html"><![CDATA[<p>For the second time since I have been at Mozilla I have encountered a situation
where hooks are called for notifications of a newly created window, but that
window has not yet been initialized properly, causing the hooks to behave badly.</p>

<p>The first time was inside our window neutering code in IPC, while the second
time was in our accessibility code.</p>

<p>Every time I have seen this, there is code that follows this pattern:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">HWND</span> <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">hwnd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Do some follow-up initialization to hwnd (Using SetProp as an example):</span>
</span><span class='line'>  <span class="n">SetProp</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This seems innocuous enough, right?</p>

<p>The problem is that <code>CreateWindowEx</code> calls hooks. If those hooks then try to do
something like <code>GetProp(hwnd, "Foo")</code>, that call is going to fail because the
&ldquo;Foo&rdquo; prop has not yet been set.</p>

<p>The key takeaway from this is that, if you are creating a new window, you must
do any follow-up initialization from within your window proc&rsquo;s <code>WM_CREATE</code>
handler. This will guarantee that your window&rsquo;s initialization will have
completed before any hooks are called.</p>

<p>You might be thinking, &ldquo;But I don&rsquo;t set any hooks!&rdquo; While this may be true, you
must not forget about hooks set by third-party code.</p>

<p>&ldquo;But those hooks won&rsquo;t know anything about my program&rsquo;s internals, right?&rdquo;</p>

<p>Perhaps, perhaps not. But when those hooks fire, they give third-party software
the opportunity to run. In some cases, those hooks might even cause the thread
to <em>reenter your own code</em>. Your window had better be completely initialized
when this happens!</p>

<p>In the case of my latest discovery of this issue in <a title="Window emulation needs to SetProp inside WM_CREATE" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1380471">bug 1380471</a>, I made it
possible to use a C++11 lambda to simplify this pattern.</p>

<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680.aspx"><code>CreateWindowEx</code></a>
accepts a <code>lpParam</code> parameter which is then passed to the <code>WM_CREATE</code> handler
as the <code>lpCreateParams</code> member of a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632603.aspx"><code>CREATESTRUCT</code></a>.</p>

<p>By setting <code>lpParam</code> to a pointer to a <code>std::function&lt;void(HWND)&gt;</code>, we may then
supply any callable that we wish for follow-up window initialization.</p>

<p>Using the previous code sample as a baseline, this allows me to revise the code
to safely set a property like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">HWND</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">onCreate</span><span class="p">([](</span><span class="n">HWND</span> <span class="n">aHwnd</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">SetProp</span><span class="p">(</span><span class="n">aHwnd</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">HWND</span> <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">onCreate</span><span class="p">);</span>
</span><span class='line'><span class="c1">// At this point is already too late to further initialize hwnd!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that since <code>lpParam</code> is always passed during <code>WM_CREATE</code>, which always fires
before <code>CreateWindowEx</code> returns, it is safe for <code>onCreate</code> to live on the stack.</p>

<p>I liked this solution for the a11y case because it preserved the locality of
the initialization code within the function that called <code>CreateWindowEx</code>; the
window proc for this window is implemented in another source file and the
follow-up initialization depends on the context surrounding the <code>CreateWindowEx</code>
call.</p>

<p>Speaking of window procs, here is how that window&rsquo;s <code>WM_CREATE</code> handler invokes
the callable:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">uMsg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">WM_CREATE</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">createStruct</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CREATESTRUCT</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">lParam</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">createProc</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">HWND</span><span class="p">)</span><span class="o">&gt;*&gt;</span><span class="p">(</span>
</span><span class='line'>      <span class="n">createStruct</span><span class="o">-&gt;</span><span class="n">lpCreateParams</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">createProc</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">createProc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">(</span><span class="o">*</span><span class="n">createProc</span><span class="p">)(</span><span class="n">hwnd</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>TL;DR:</strong> If you see a pattern where further initialization work is being done
on an <code>HWND</code> after a <code>CreateWindowEx</code> call, move that initialization code to your
window&rsquo;s <code>WM_CREATE</code> handler instead.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I Prefer Using CRITICAL_SECTIONs for Mutexes in Windows Nightly Builds]]></title>
    <link href="http://dblohm7.ca/blog/2017/06/12/why-i-prefer-using-critical-sections-for-mutexes-in-windows-nightly-builds/"/>
    <updated>2017-06-12T15:50:43-06:00</updated>
    <id>http://dblohm7.ca/blog/2017/06/12/why-i-prefer-using-critical-sections-for-mutexes-in-windows-nightly-builds</id>
    <content type="html"><![CDATA[<p>In the past I have argued that our Nightly builds, both debug and release, should
use <code>CRITICAL_SECTION</code>s (with full debug info) for our implementation of
<code>mozilla::Mutex</code>. I&rsquo;d like to illustrate some reasons why this is so useful.</p>

<h2>They enable more utility in WinDbg extensions</h2>

<p>Every time you initialize a <code>CRITICAL_SECTION</code>, Windows inserts the CS&rsquo;s
debug info into a process-wide linked list. This enables their discovery by
the Windows debugging engine, and makes the <code>!cs</code>, <code>!critsec</code>, and <code>!locks</code>
commands more useful.</p>

<h2>They enable profiling of their initialization and acquisition</h2>

<p>When the &ldquo;Create user mode stack trace database&rdquo; gflag is enabled, Windows
records the call stack of the thread that called <code>InitializeCriticalSection</code>
on that CS. Windows also records the call stack of the owning thread once
it has acquired the CS. This can be very useful for debugging deadlocks.</p>

<h2>They track their contention counts</h2>

<p>Since every CS has been placed in a process-wide linked list, we may now ask
the debugger to dump statistics about every live CS in the process. In
particular, we can ask the debugger to output the contention counts for each
CS in the process. After running a workload against Nightly, we may then take
the contention output, sort it descendingly, and be able to determine which
<code>CRITICAL_SECTION</code>s are the most contended in the process.</p>

<p>We may then want to more closely inspect the hottest CSes to determine whether
there is anything that we can do to reduce contention and all of the extra
context switching that entails.</p>

<h2>In Summary</h2>

<p>When we use <code>SRWLOCK</code>s or initialize our <code>CRITICAL_SECTION</code>s with the
<code>CRITICAL_SECTION_NO_DEBUG_INFO</code> flag, we are denying ourselves access to this
information. That&rsquo;s fine on release builds, but on Nightly I think it is worth
having around. While I realize that most Mozilla developers have not used this
until now (otherwise I would not be writing this blog post), this rich debugger
info is one of those things that you do not miss until you do not have it.</p>

<p>For further reading about critical section debug info, check out
<a href="https://web.archive.org/web/20150419055323/https://msdn.microsoft.com/en-us/magazine/cc164040.aspx">this</a>
archived article from MSDN Magazine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asynchronous Plugin Initialization: Requiem]]></title>
    <link href="http://dblohm7.ca/blog/2017/04/07/asynchronous-plugin-initialization-requiem/"/>
    <updated>2017-04-07T15:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2017/04/07/asynchronous-plugin-initialization-requiem</id>
    <content type="html"><![CDATA[<p>My colleague <del>bsmedberg</del> njn is going to be removing asynchronous plugin
initialization in <a title="Remove support for async plugin init" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1352575">bug 1352575</a>. Sadly the feature never became solid enough
to remain enabled on release, so we cut our losses and cancelled the project
early in 2016. Now that code is just a bunch of dead weight. With the
deprecation of non-Flash NPAPI plugins in Firefox 52, our developers are now
working on simplifying the remaining NPAPI code as much as possible.</p>

<p>Obviously the removal of that code does not prevent me from discussing some of
the more interesting facets of that work.</p>

<p>Today I am going to talk about how async plugin init worked when web content
attempted to access a property on a plugin&rsquo;s scriptable object, when that
plugin had not yet completed its asynchronous initialization.</p>

<p>As <a href="https://developer.mozilla.org/en-US/docs/Plugins/Guide/Scripting_plugins">described on MDN</a>,
the DOM queries a plugin for scriptability by calling <code>NPP_GetValue</code> with the
<code>NPPVpluginScriptableNPObject</code> constant. With async plugin init, we did not
return the true NPAPI scriptable object back to the DOM. Instead we returned
a surrogate object. This meant that we did not need to synchronously wait for
the plugin to initialize before returning a result back to the DOM.</p>

<p>If the DOM subsequently called into that surrogate object, the surrogate would
be forced to synchronize with the plugin. There was a limit on how much fakery
the async surrogate could do once the DOM needed a definitive answer &ndash; after
all, the NPAPI itself is entirely synchronous. While you may question whether
the asynchronous surrogate actually bought us any responsiveness, performance
profiles and measurements that I took at the time did indeed demonstrate that
the asynchronous surrogate did buy us enough additional concurrency to make it
worthwhile. A good number of plugin instantiations were able to complete in
time before the DOM had made a single invocation on the surrogate.</p>

<p>Once the surrogate object had synchronized with the plugin, it would then mostly
act as a pass-through to the plugin&rsquo;s real NPAPI scriptable object, with one
notable exception: property accesses.</p>

<p>The reason for this is not necessarily obvious, so allow me to elaborate:</p>

<p>The DOM usually sets up a scriptable object as follows:</p>

<pre><samp>
this.__proto__.__proto__.__proto__
</samp></pre>


<ul>
<li>Where <code>this</code> is the WebIDL object (ie, content&rsquo;s <code>&lt;embed&gt;</code> element);</li>
<li>Whose prototype is the NPAPI scriptable object;</li>
<li>Whose prototype is the shared WebIDL prototype;</li>
<li>Whose prototype is <code>Object.prototype</code>.</li>
</ul>


<p>NPAPI is reentrant (some might say <em>insanely</em> reentrant). It is possible (and
indeed common) for a plugin to set properties on the WebIDL object from within
the plugin&rsquo;s <code>NPP_New</code>.</p>

<p>Suppose that the DOM tries to access a property on the plugin&rsquo;s WebIDL object
that is normally set by the plugin&rsquo;s <code>NPP_New</code>. In the asynchronous case, the
plugin&rsquo;s initialization might still be in progress, so that property might not
yet exist.</p>

<p>In the case where the property does not yet exist on the WebIDL object, JavaScript
fails to retrieve an &ldquo;own&rdquo; property. It then moves on to the first prototype
and attempts to resolve the property on that. As outlined above, this prototype
would actually be the async surrogate. The async surrogate would then be in a
situation where it must absolutely produce a definitive result, so this would
trigger synchronization with the plugin. At this point the plugin would be
guaranteed to have finished initializing.</p>

<p>Now we have a problem: JS was already examining the NPAPI scriptable object when
it blocked to synchronize with the plugin. Meanwhile, the plugin went ahead and
set properties (including the one that we&rsquo;re interested in) on the WebIDL object.
By the time that JS execution resumes, it would already be looking too far up the
prototype chain to see those new properties!</p>

<p>The surrogate needed to be aware of this when it synchronized with the plugin
during a property access. If the plugin had already completed its initialization
(thus rendering synchronization unnecessary), the surrogate would simply pass the
property access on to the real NPAPI scriptable object. On the other hand, if a
synchronization was performed, the surrogate would first retry the WebIDL object
by querying for the WebIDL object&rsquo;s &ldquo;own&rdquo; properties, and return the own property
if it now existed. If no own property existed on the WebIDL object, then the
surrogate would revert to its &ldquo;pass through all the things&rdquo; behaviour.</p>

<p>If I hadn&rsquo;t made the asynchronous surrogate scriptable object do that, we would
have ended up with a strange situation where the DOM&rsquo;s initial property access
on an embed could fail non-deterministically during page load.</p>

<p>That&rsquo;s enough chatter for today. I enjoy blogging about my crazy hacks that make
the impossible, umm&hellip; possible, so maybe I&rsquo;ll write some more of these in the
future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Team, New Project]]></title>
    <link href="http://dblohm7.ca/blog/2016/04/06/new-team-new-project/"/>
    <updated>2016-04-06T21:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2016/04/06/new-team-new-project</id>
    <content type="html"><![CDATA[<p>In February of this year I switched teams: After 3+ years on Mozilla&rsquo;s
Performance Team, and after having the word &ldquo;performance&rdquo; in my job description
in some form or another for several years prior to that, I decided that it was
time for me to move on to new challenges. Fortunately the Platform org was
willing to have me set up shop under the (e10s|sandboxing|platform integration)
umbrella.</p>

<p>I am pretty excited about this new role!</p>

<p>My first project is to sort out the accessibility situation under Windows e10s.
This started back at Mozlando last December. A number of engineers from across
the Platform org, plus me, got together to brainstorm. Not too long after we had
all returned home, I ended up making a suggestion on an email thread that has
evolved into the core concept that I am currently attempting. As is typical at
Mozilla, no deed goes unpunished, so I have been asked to flesh out my ideas.
An overview of this plan is available on the <a href="https://wiki.mozilla.org/Electrolysis/Accessibility/Windows">wiki</a>.</p>

<p>My hope is that I&rsquo;ll be able to deliver a working, &ldquo;version 0.9&rdquo; type of demo
in time for our London all-hands at the end of Q2. Hopefully we will be able to
deliver on that!</p>

<h2>Some Additional Notes</h2>

<p>I am using this section of the blog post to make some additional notes. I don&rsquo;t
feel that these ideas are strong enough to commit to a wiki yet, but I do want
them to be publicly available.</p>

<p>Once concern that our colleagues at NVAccess have identified is that the
current COM interfaces are too chatty; this is a major reason why screen
readers frequently inject libraries into the Firefox address space. If we serve
our content a11y objects as remote COM objects, there is concern that performance
would suffer. This concern is not due to latency, but rather due to frequency
of calls; one function call does not provide sufficient information to the a11y
client. As a result, multiple round trips are required to fetch all of the
information that is required for a particular DOM node.</p>

<p>My gut feeling about this is that this is probably a legitimate concern, however
we cannot make good decisions without quantifying the performance. My plan going
forward is to proceed with a na&iuml;ve implementation of COM remoting to start,
followed by work on reducing round trips as necessary.</p>

<h2>Smart Proxies</h2>

<p>One idea that was discussed is the idea of the content process speculatively
sending information to the chrome process that might be needed in the future.
For example, if we have an <code>IAccessible</code>, we can expect that multiple properties
will be queried off that interface. A smart proxy could ship that data across
the RPC channel during marshaling so that querying that additional information
does not require additional round trips.</p>

<p>COM makes this possible using &ldquo;handler marshaling.&rdquo; I have dug up some
information about how to do this and am posting it here for posterity:</p>

<p><a href="https://www.microsoft.com/msj/0599/com/com0599.aspx">House of COM, May 1999 <em>Microsoft Systems Journal</em></a>;<br/>
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683786.aspx">Implementing and Activating a Handler with Extra Data Supplied by Server</a> on MSDN;<br/>
Wicked Code, August 2000 <em>MSDN Magazine</em>. This is not available on the MSDN Magazine website but I have an archived copy on CD-ROM.<br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Mozdbgext Command: !iat]]></title>
    <link href="http://dblohm7.ca/blog/2016/02/11/new-mozdbgext-command-iat/"/>
    <updated>2016-02-11T18:30:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2016/02/11/new-mozdbgext-command-iat</id>
    <content type="html"><![CDATA[<p>As of today I have added a new command to <code>mozdbgext</code>: <code>!iat</code>.</p>

<p>The syntax is pretty simple:</p>

<p><code>!iat &lt;hexadecimal address&gt;</code></p>

<p>This address shouldn&rsquo;t be just any pointer; it should be the address of an
entry in the current module&rsquo;s import address table (IAT). These addresses
are typically very identifiable by the <code>_imp_</code> prefix in their symbol names.</p>

<p>The purpose of this extension is to look up the name of the DLL from whom the
function is being imported. Furthermore, the extension checks the expected
target address of the import with the actual target address of the import. This
allows us to detect API hooking via IAT patching.</p>

<h3>An Example Session</h3>

<p>I fired up a local copy of Nightly, attached a debugger to it, and dumped the
call stack of its main thread:</p>

<pre><samp>
 # ChildEBP RetAddr
00 0018ecd0 765aa32a ntdll!NtWaitForMultipleObjects+0xc
01 0018ee64 761ec47b KERNELBASE!WaitForMultipleObjectsEx+0x10a
02 0018eecc 1406905a USER32!MsgWaitForMultipleObjectsEx+0x17b
03 0018ef18 1408e2c8 xul!mozilla::widget::WinUtils::WaitForMessage+0x5a
04 0018ef84 13fdae56 xul!nsAppShell::ProcessNextNativeEvent+0x188
05 0018ef9c 13fe3778 xul!nsBaseAppShell::DoProcessNextNativeEvent+0x36
06 0018efbc 10329001 xul!nsBaseAppShell::OnProcessNextEvent+0x158
07 0018f0e0 1038e612 xul!nsThread::ProcessNextEvent+0x401
08 0018f0fc 1095de03 xul!NS_ProcessNextEvent+0x62
09 0018f130 108e493d xul!mozilla::ipc::MessagePump::Run+0x273
0a 0018f154 108e48b2 xul!MessageLoop::RunInternal+0x4d
0b 0018f18c 108e448d xul!MessageLoop::RunHandler+0x82
0c 0018f1ac 13fe78f0 xul!MessageLoop::Run+0x1d
0d 0018f1b8 14090f07 xul!nsBaseAppShell::Run+0x50
0e 0018f1c8 1509823f xul!nsAppShell::Run+0x17
0f 0018f1e4 1514975a xul!nsAppStartup::Run+0x6f
10 0018f5e8 15146527 xul!XREMain::XRE_mainRun+0x146a
11 0018f650 1514c04a xul!XREMain::XRE_main+0x327
12 0018f768 00215c1e xul!XRE_main+0x3a
13 0018f940 00214dbd firefox!do_main+0x5ae
14 0018f9e4 0021662e firefox!NS_internal_main+0x18d
15 0018fa18 0021a269 firefox!wmain+0x12e
16 0018fa60 76e338f4 firefox!__tmainCRTStartup+0xfe
17 0018fa74 77d656c3 KERNEL32!BaseThreadInitThunk+0x24
18 0018fabc 77d6568e ntdll!__RtlUserThreadStart+0x2f
19 0018facc 00000000 ntdll!_RtlUserThreadStart+0x1b
</samp></pre>


<p>Let us examine the code at frame 3:</p>

<pre><samp>
14069042 6a04            push    4
14069044 68ff1d0000      push    1DFFh
14069049 8b5508          mov     edx,dword ptr [ebp+8]
1406904c 2b55f8          sub     edx,dword ptr [ebp-8]
1406904f 52              push    edx
14069050 6a00            push    0
14069052 6a00            push    0
14069054 ff159cc57d19    call    dword ptr [xul!_imp__MsgWaitForMultipleObjectsEx (197dc59c)]
1406905a 8945f4          mov     dword ptr [ebp-0Ch],eax
</samp></pre>


<p>Notice the function call to <code>MsgWaitForMultipleObjectsEx</code> occurs indirectly;
the call instruction is referencing a pointer within the <code>xul.dll</code> binary
itself. This is the IAT entry that corresponds to that function.</p>

<p>Now, if I load <code>mozdbgext</code>, I can take the address of that IAT entry and execute
the following command:</p>

<pre><samp>
0:000> !iat 0x197dc59c
Expected target: USER32.dll!MsgWaitForMultipleObjectsEx
Actual target: USER32!MsgWaitForMultipleObjectsEx+0x0
</samp></pre>


<p><code>!iat</code> has done two things for us:</p>

<ol>
<li>It did a reverse lookup to determine the module and function name for the
import that corresponds to that particular IAT entry; and</li>
<li>It followed the IAT pointer and determined the symbol at the target address.</li>
</ol>


<p>Normally we want both the expected and actual targets to match. If they don&rsquo;t,
we should investigate further, as this mismatch may indicate that the IAT has
been patched by a third party.</p>

<p>Note that <code>!iat</code> command is breakpad aware (provided that you&rsquo;ve already
loaded the symbols using <code>!bploadsyms</code>) but can fall back to the Microsoft
symbol engine as necessary.</p>

<p>Further note that the <code>!iat</code> command does not yet accept the <code>_imp_</code> symbolic
names for the IAT entries, you need to enter the hexadecimal representation of
the pointer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Announcing Mozdbgext]]></title>
    <link href="http://dblohm7.ca/blog/2016/01/26/announcing-mozdbgext/"/>
    <updated>2016-01-26T12:45:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2016/01/26/announcing-mozdbgext</id>
    <content type="html"><![CDATA[<p>A well-known problem at Mozilla is that, while most of our desktop users run
Windows, most of Mozilla&rsquo;s developers do not. There are a lot of problems that
result from that, but one of the most frustrating to me is that sometimes
those of us that actually use Windows for development find ourselves at a
disadvantage when it comes to tooling or other productivity enhancers.</p>

<p>In many ways this problem is also a Catch-22: People don&rsquo;t want to use Windows
for many reasons, but tooling is big part of the problem. OTOH, nobody is
motivated to improve the tooling situation if nobody is actually going to
use them.</p>

<p>A couple of weeks ago my frustrations with the situation boiled over when I
learned that our <code>Cpp</code> unit test suite could not log symbolicated call stacks,
resulting in my filing of <a title="cppunittests do not look up breakpad symbols for logged stack traces" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1238305">bug 1238305</a> and <a title="Set _NT_SYMBOL_PATH on Windows test machines" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1240605">bug 1240605</a>. Not only could we
not log those stacks, in many situations we could not view them in a debugger
either.</p>

<p>Due to the fact that PDB files consume a large amount of disk space, we don&rsquo;t
keep those when building from integration or try repositories. Unfortunately
they are be quite useful to have when there is a build failure. Most of our
integration builds, however, do include breakpad symbols. Developers may also
explicitly <a href="https://wiki.mozilla.org/ReleaseEngineering/TryServer#Getting_debug_symbols">request symbols</a>
for their try builds.</p>

<p>A couple of years ago I had begun working on a WinDbg debugger extension that
was tailored to Mozilla development. It had mostly bitrotted over time, but I
decided to resurrect it for a new purpose: to help WinDbg<sup><a href="#fn1" id="r1">*</a></sup>
grok breakpad.</p>

<h2>Enter mozdbgext</h2>

<p><a href="https://github.com/dblohm7/mozdbgext"><code>mozdbgext</code></a> is the result. This extension
adds a few commands that makes Win32 debugging with breakpad a little bit easier.</p>

<p>The original plan was that I wanted <code>mozdbgext</code> to load breakpad symbols and then
insert them into the debugger&rsquo;s symbol table via the <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff537943%28v=vs.85%29.aspx"><code>IDebugSymbols3::AddSyntheticSymbol</code></a>
API. Unfortunately the design of this API is not well equipped for bulk loading
of synthetic symbols: each individual symbol insertion causes the debugger to
re-sort its entire symbol table. Since <code>xul.dll</code>&rsquo;s quantity of symbols is in the
six-figure range, using this API to load that quantity of symbols is
prohibitively expensive. I tweeted a Microsoft PM who works on Debugging Tools
for Windows, asking if there would be any improvements there, but it sounds like
this is not going to be happening any time soon.</p>

<p>My original plan would have been ideal from a UX perspective: the breakpad
symbols would look just like any other symbols in the debugger and could be
accessed and manipulated using the same set of commands. Since synthetic symbols
would not work for me in this case, I went for &ldquo;Plan B:&rdquo; Extension commands that
are separate from, but analagous to, regular WinDbg commands.</p>

<p>I plan to continuously improve the commands that are available. Until I have a
proper README checked in, I&rsquo;ll introduce the commands here.</p>

<h3>Loading the Extension</h3>

<ol>
<li>Use the <code>.load</code> command: <code>.load &lt;path_to_mozdbgext_dll&gt;</code></li>
</ol>


<h3>Loading the Breakpad Symbols</h3>

<ol>
<li>Extract the breakpad symbols into a directory.</li>
<li>In the debugger, enter <code>!bploadsyms &lt;path_to_breakpad_symbol_directory&gt;</code></li>
<li>Note that this command will take some time to load all the relevant symbols.</li>
</ol>


<h3>Working with Breakpad Symbols</h3>

<p><strong>Note: You must have successfully run the <code>!bploadsyms</code> command first!</strong></p>

<p>As a general guide, I am attempting to name each breakpad command similarly to
the native WinDbg command, except that the command name is prefixed by <code>!bp</code>.</p>

<ul>
<li>Stack trace: <code>!bpk</code></li>
<li>Find nearest symbol to address: <code>!bpln &lt;address&gt;</code> where <em>address</em> is specified
as a hexadecimal value.</li>
</ul>


<h3>Downloading windbgext</h3>

<p>I have pre-built binaries (<a href="https://github.com/dblohm7/mozdbgext/blob/master/bin/32/mozdbgext.dll?raw=true">32-bit</a>, <a href="https://github.com/dblohm7/mozdbgext/blob/master/bin/64/mozdbgext.dll?raw=true">64-bit</a>) available for download.</p>

<p>Note that there are several other commands that are &ldquo;roughed-in&rdquo; at this point
and do not work correctly yet. Please stick to the documented commands at this
time.</p>

<hr />

<p><sup><a href="#r1" id="fn1">*</a></sup> When I write &ldquo;WinDbg&rdquo;, I am really
referring to any debugger in the <em>Debugging Tools for Windows</em> package,
including <code>cdb</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs From Hell: Injected Third-party Code + Detours = a Bad Time]]></title>
    <link href="http://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time/"/>
    <updated>2016-01-11T13:00:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2016/01/11/bugs-from-hell-injected-third-party-code-plus-detours-equals-a-bad-time</id>
    <content type="html"><![CDATA[<p>Happy New Year!</p>

<p>I&rsquo;m finally getting &lsquo;round to writing about a nasty bug that I had to spend a
bunch of time with in Q4 2015. It&rsquo;s one of the more challenging problems that
I&rsquo;ve had to break and I&rsquo;ve been asked a lot of questions about it. I&rsquo;m talking
about <a title="Crash spike in CreateWindowEx with Firefox 42.0b9 on Optimus" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473">bug 1218473</a>.</p>

<h2>How This All Began</h2>

<p>In <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a> I had landed a patch to intercept calls to <code>CreateWindowEx</code>.
This was necessary because it was apparent in that bug that window subclassing
was occurring while a window was neutered (&ldquo;neutering&rdquo; is terminology that is
specific to Mozilla&rsquo;s Win32 IPC code).</p>

<p>While I&rsquo;ll save a discussion on the specifics of window neutering for another
day, for our purposes it is sufficient for me to point out that subclassing a
neutered window is bad because it creates an infinite recursion scenario with
window procedures that will eventually overflow the stack.</p>

<p>Neutering is triggered during certain types of IPC calls as soon as a message is
sent to an unneutered window on the thread making the IPC call. Unfortunately in
the case of <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, the message triggering the neutering was
<code>WM_CREATE</code>. Shortly after creating that window, the code responsible would
subclass said window. Since <code>WM_CREATE</code> had already triggered neutering, this
would result in the pathological case that triggers the stack overflow.</p>

<p>For a fix, what I wanted to do is to prevent messages that were sent immediately
during the execution of <code>CreateWindow</code> (such as <code>WM_CREATE</code>) from triggering
neutering prematurely. By intercepting calls to <code>CreateWindowEx</code>, I could wrap
those calls with a RAII object that temporarily suppresses the neutering. Since
the subclassing occurs immediately after window creation, this meant that
this subclassing operation was now safe.</p>

<p>Unfortunately, shortly after landing <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, <a title="Crash spike in CreateWindowEx with Firefox 42.0b9 on Optimus" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473">bug 1218473</a> was filed.</p>

<h2>Where to Start</h2>

<p>It wasn&rsquo;t obvious where to start debugging this. While a crash spike was clearly
correlated with the landing of <a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, the crashes were occurring in
code that had nothing to do with IPC or Win32. For example, the first stack that
I looked at was <code>js::CreateRegExpMatchResult</code>!</p>

<p>When it is just not clear where to begin, I like to start by looking at our
correlation data in Socorro &ndash; you&rsquo;d be surprised how often they can bring
problems into sharp relief!</p>

<p>In this case, the correlation data didn&rsquo;t disappoint: there
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473#c10">was</a> 100% correlation
with a module called <code>_etoured.dll</code>. There was also correlation with the
presence of both NVIDIA video drivers <em>and</em> Intel video drivers. Clearly this
was a concern only when NVIDIA Optimus technology was enabled.</p>

<p>I also had a pretty strong hypothesis about what <code>_etoured.dll</code> was: For many
years, Microsoft Research has shipped a package called
<a href="http://research.microsoft.com/en-us/projects/detours/">Detours</a>. Detours is a
library that is used for intercepting Win32 API calls. While the changelog for
Detours 3.0 points out that it has &ldquo;Removed [the] requirement for including
<code>detoured.dll</code> in processes,&rdquo; in previous versions of the package, this library
was required to be injected into the target process.</p>

<p>I concluded that <code>_etoured.dll</code> was most likely a renamed version of
<code>detoured.dll</code> from Detours 2.x.</p>

<h2>Following The Trail</h2>

<p>Now that I knew the likely culprit, I needed to know how it was getting there.
During a November trip to the Mozilla Toronto office, I spent some time
debugging a test laptop that was configured with Optimus.</p>

<p>Knowing that the presence of Detours was somehow interfering with our own API
interception, I decided to find out whether it was also trying to intercept
<code>CreateWindowExW</code>. I launched <code>windbg</code>, started Firefox with it, and then told
it to break as soon as <code>user32.dll</code> was loaded:</p>

<pre><samp>
sxe ld:user32.dll
</samp></pre>


<p>Then I pressed <code>F5</code> to resume execution. When the debugger broke again, this
time <code>user32</code> was now in memory. I wanted the debugger to break as soon as
<code>CreateWindowExW</code> was touched:</p>

<pre><samp>
ba w 4 user32!CreateWindowExW
</samp></pre>


<p>Once again I resumed execution. Then the debugger broke on the memory access and
gave me this call stack:</p>

<pre><samp>
nvd3d9wrap!setDeviceHandle+0x1c91
nvd3d9wrap!initialise+0x373
nvd3d9wrap!setDeviceHandle+0x467b
nvd3d9wrap!setDeviceHandle+0x4602
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
KERNELBASE!LoadLibraryExA+0x26
kernel32!LoadLibraryA+0xba
nvinit+0x11cb
nvinit+0x5477
nvinit!nvCoprocThunk+0x6e94
nvinit!nvCoprocThunk+0x6e1a
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
kernel32!BasepLoadAppInitDlls+0x167
kernel32!LoadAppInitDlls+0x82
USER32!ClientThreadSetup+0x1f9
USER32!__ClientThreadSetup+0x5
ntdll!KiUserCallbackDispatcher+0x2e
GDI32!GdiDllInitialize+0x1c
USER32!_UserClientDllInitialize+0x32f
ntdll!LdrpCallInitRoutine+0x14
ntdll!LdrpRunInitializeRoutines+0x26f
ntdll!LdrpLoadDll+0x453
ntdll!LdrLoadDll+0xaa
mozglue!`anonymous namespace'::patched_LdrLoadDll+0x1b0
KERNELBASE!LoadLibraryExW+0x1f7
firefox!XPCOMGlueLoad+0x23c
firefox!XPCOMGlueStartup+0x1d
firefox!InitXPCOMGlue+0xba
firefox!NS_internal_main+0x5c
firefox!wmain+0xbe
firefox!__tmainCRTStartup+0xfe
kernel32!BaseThreadInitThunk+0xe
ntdll!__RtlUserThreadStart+0x70
ntdll!_RtlUserThreadStart+0x1b
</samp></pre>


<p>This stack is a gold mine of information. In particular, it tells us the
following:</p>

<ol>
<li><p>The offending DLLs are being injected by <code>AppInit_DLLs</code> (and in fact, Raymond
Chen <a href="https://blogs.msdn.microsoft.com/oldnewthing/20140422-00/?p=1173">has blogged about</a>
this exact case in the past).</p></li>
<li><p><code>nvinit.dll</code> is the name of the DLL that is injected by step 1.</p></li>
<li><p><code>nvinit.dll</code> loads <code>nvd3d9wrap.dll</code> which then uses Detours to patch
our copy of <code>CreateWindowExW</code>.</p></li>
</ol>


<p>I then became curious as to which other functions they were patching.</p>

<p>Since Detours is patching executable code, we know that at some point it is
going to need to call <code>VirtualProtect</code> to make the target code writable. In the
worst case, <code>VirtualProtect</code>&rsquo;s caller is going to pass the address of the page
where the target code resides. In the best case, the caller will pass in the
address of the target function itself!</p>

<p>I restarted <code>windbg</code>, but this time I set a breakpoint on <code>VirtualProtect</code>:</p>

<pre><samp>
bp kernel32!VirtualProtect
</samp></pre>


<p>I then resumed the debugger and examined the call stack every time it broke.
While not every single <code>VirtualProtect</code> call would correspond to a detour, it
would be obvious when it was, as the NVIDIA DLLs would be on the call stack.</p>

<p>The first time I caught a detour, I examined the address being passed to
<code>VirtualProtect</code>: I ended up with the best possible case: the address was
pointing to the actual target function! From there I was able to distill a
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1218473#c39">list</a> of other
functions being hooked by the injected NVIDIA DLLs.</p>

<h2>Putting it all Together</h2>

<p>By this point I knew who was hooking our code and knew how it was getting there.
I also noticed that <code>CreateWindowEx</code> is the only function that the NVIDIA DLLs
and our own code were both trying to intercept. Clearly there was some kind of
bad interaction occurring between the two interception mechanisms, but what was
it?</p>

<p>I decided to go back and examine a
<a href="https://crash-stats.mozilla.com/report/index/e884dc17-957f-4270-86ab-f59742151113">specific</a>
crash dump. In particular, I wanted to examine three different memory locations:</p>

<ol>
<li>The first few instructions of <code>user32!CreateWindowExW</code>;</li>
<li>The first few instructions of <code>xul!CreateWindowExWHook</code>; and</li>
<li>The site of the call to <code>user32!CreateWindowExW</code> that triggered the crash.</li>
</ol>


<p>Of those three locations, the only one that looked off was location 2:</p>

<pre><samp>
6b1f6611 56              push    esi
6b1f6612 ff15f033e975    call    dword ptr [combase!CClassCache::CLSvrClassEntry::GetDDEInfo+0x41 (75e933f0)]
6b1f6618 c3              ret
6b1f6619 7106            jno     xul!`anonymous namespace'::CreateWindowExWHook+0x6 (6b1f6621)
xul!`anonymous namespace'::CreateWindowExWHook:
6b1f661b cc              int     3
6b1f661c cc              int     3
6b1f661d cc              int     3
6b1f661e cc              int     3
6b1f661f cc              int     3
6b1f6620 cc              int     3
6b1f6621 ff              ???
</samp></pre>


<p><em>Why the hell were the first six bytes filled with breakpoint instructions?</em></p>

<p>I decided at this point to look at some source code. Fortunately Microsoft
publishes the 32-bit source code for Detours, licensed for non-profit use,
under the name &ldquo;Detours Express.&rdquo;</p>

<p>I found a copy of Detours Express 2.1 and checked out the code. First I wanted
to know where all of these <code>0xcc</code> bytes were coming from. A quick <code>grep</code> turned
up what I was looking for:</p>

<figure class='code'><figcaption><span>detours.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kr">inline</span> <span class="n">PBYTE</span> <span class="nf">detour_gen_brk</span><span class="p">(</span><span class="n">PBYTE</span> <span class="n">pbCode</span><span class="p">,</span> <span class="n">PBYTE</span> <span class="n">pbLimit</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">pbCode</span> <span class="o">&lt;</span> <span class="n">pbLimit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">*</span><span class="n">pbCode</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xcc</span><span class="p">;</span>   <span class="c1">// brk;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">pbCode</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now that I knew which function was generating the <code>int 3</code> instructions, I then
wanted to find its callers. Soon I found:</p>

<figure class='code'><figcaption><span>detours.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1247</span>
<span class='line-number'>1248</span>
<span class='line-number'>1249</span>
<span class='line-number'>1250</span>
<span class='line-number'>1251</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#ifdef DETOURS_X86</span>
</span><span class='line'>    <span class="n">pbSrc</span> <span class="o">=</span> <span class="n">detour_gen_jmp_immediate</span><span class="p">(</span><span class="n">pTrampoline</span><span class="o">-&gt;</span><span class="n">rbCode</span> <span class="o">+</span> <span class="n">cbTarget</span><span class="p">,</span> <span class="n">pTrampoline</span><span class="o">-&gt;</span><span class="n">pbRemain</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pbSrc</span> <span class="o">=</span> <span class="n">detour_gen_brk</span><span class="p">(</span><span class="n">pbSrc</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">pTrampoline</span><span class="o">-&gt;</span><span class="n">rbCode</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pTrampoline</span><span class="o">-&gt;</span><span class="n">rbCode</span><span class="p">));</span>
</span><span class='line'><span class="cp">#endif </span><span class="c1">// DETOURS_X86</span>
</span></code></pre></td></tr></table></div></figure>


<p>Okay, so Detours writes the breakpoints out immediately after it has written a
<code>jmp</code> pointing to its trampoline.</p>

<p><em>Why is our hook function being trampolined?</em></p>

<p>The reason must be because our hook was installed first! Detours has
detected that and has decided that the best place to trampoline to the NVIDIA
hook is at the beginning of our hook function.</p>

<p><em>But Detours is using the wrong address!</em></p>

<p>We can see that because the <code>int 3</code> instructions are written out at the
<em>beginning</em> of <code>CreateWindowExWHook</code>, even though there should be a <code>jmp</code>
instruction first.</p>

<p><strong>Detours is calculating the wrong address to write its <code>jmp</code>!</strong></p>

<h2>Finding a Workaround</h2>

<p>Once I knew <em>what</em> the problem was, I needed to know more about the <em>why</em> &ndash;
only then would I be able to come up with a way to work around this problem.</p>

<p>I decided to reconstruct the scenario where both our code and Detours are trying
to hook the same function, but our hook was installed first. I would then
follow along through the Detours code to determine how it calculated the wrong
address to install its <code>jmp</code>.</p>

<p>The first thing to keep in mind is that Mozilla&rsquo;s function interception code
takes advantage of <a href="https://blogs.msdn.microsoft.com/oldnewthing/20110921-00/?p=9583">hot-patch points</a>
in Windows. If the target function begins with a <code>mov edi, edi</code> prolog, we
use a hot-patch style hook instead of a trampoline hook. I am not going to go
into detail about hot-patch hooks here &ndash; the above Raymond Chen link contains
enough details to answer your questions. For the purposes of this blog post, the
important point is that Mozilla&rsquo;s code patches the <code>mov edi, edi</code>, so NVIDIA&rsquo;s
Detours library would need to recognize and follow the <code>jmp</code>s that our code
patched in, in order to write its own <code>jmp</code> at <code>CreateWindowExWHook</code>.</p>

<p>Tracing through the Detours code, I found the place where it checks for a
hot-patch hook and follows the <code>jmp</code> if necessary. While examining a function
called <code>detour_skip_jmp</code>, I found the bug:</p>

<figure class='code'><figcaption><span>detours.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>124</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>        <span class="n">pbNew</span> <span class="o">=</span> <span class="n">pbCode</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="n">INT32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pbCode</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code is supposed to be telling Detours where the target address of a <code>jmp</code>
is, so that Detours can follow it. <code>pbNew</code> is supposed to be the target address
of the <code>jmp</code>. <code>pbCode</code> is referencing the address <em>of the beginning of the <code>jmp</code>
instruction itself</em>. Unfortunately, with this type of <code>jmp</code> instruction, target
addresses are always relative to the address of the <em>next</em> instruction, not
the <em>current</em> instruction! Since the current <code>jmp</code> instruction is five bytes
long, Detours ends up writing its <code>jmp</code> <em>five bytes prior</em> to the intended
target address!</p>

<p>I went and checked the source code for Detours Express 3.0 to see if this had
been fixed, and indeed it had:</p>

<figure class='code'><figcaption><span>detours.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>163</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>        <span class="n">PBYTE</span> <span class="n">pbNew</span> <span class="o">=</span> <span class="n">pbCode</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="n">INT32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pbCode</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>That doesn&rsquo;t do much for me right now, however, since the NVIDIA stuff is still
using Detours 2.x.</p>

<p>In the case of Mozilla&rsquo;s code, there is legitimate executable code at that
incorrect address that Detours writes to. It is corrupting the last few
instructions of that function, thus explaining those mysterious crashes that
were seemingly unrelated code.</p>

<p>I confirmed this by downloading the binaries from the build that was associated
with the crash dump that I was analyzing. [As an aside, I should point out that
you need to grab the <em>identical</em> binaries for this exercise; you cannot build
from the same source revision and expect this to work due to variability that
is introduced into builds by things like PGO.]</p>

<p>The five bytes preceeding <code>CreateWindowExHookW</code> in the crash dump diverged from
those same bytes in the original binaries. I could also make out that the
overwritten bytes consisted of a <code>jmp</code> instruction.</p>

<h3>In Summary</h3>

<p>Let us now review what we know at this point:</p>

<ul>
<li>Detours 2.x doesn&rsquo;t correctly follow <code>jmp</code>s from hot-patch hooks;</li>
<li>If Detours tries to hook something that has already been hot-patched
(including legitimate hot patches from Microsoft), it will write bytes at
incorrect addresses;</li>
<li>NVIDIA Optimus injects this buggy code into everybody&rsquo;s address spaces via an
<code>AppInit_DLLs</code> entry for <code>nvinit.dll</code>.</li>
</ul>


<p>How can we best distill this into a suitable workaround?</p>

<p>One option could be to block the NVIDIA DLLs outright. In most cases this would
probably be the simplest option, but I was hesitant to do so this time. I was
concerned about the unintended consequences of blocking what, for better or
worse, is a user-mode component of NVIDIA video drivers.</p>

<p>Instead I decided to take advantage of the fact that we now know how this bug is
triggered. I have modified our API interception code such that if it detects
the presence of NVIDIA Optimus, it disables hot-patch style hooks.</p>

<p>Not only will this take care of the crash spike that started when I landed
<a title="crash in mozilla::widget::TSFStaticSink::EnsureInitActiveTIPKeyboard()" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1213567">bug 1213567</a>, I also expect it to take care of other crash signatures
whose relationship to this bug was not obvious.</p>

<p>That concludes this episode of <em>Bugs from Hell</em>. Until next time&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On WebExtensions]]></title>
    <link href="http://dblohm7.ca/blog/2015/08/30/on-webextensions/"/>
    <updated>2015-08-30T02:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2015/08/30/on-webextensions</id>
    <content type="html"><![CDATA[<p>There has been enough that has been said over the past week about <a href="https://blog.mozilla.org/addons/2015/08/21/the-future-of-developing-firefox-add-ons/">WebExtensions</a>
that I wasn&rsquo;t sure if I wanted to write this post. As usual, I can&rsquo;t seem to
help myself. Note the usual disclaimer that this is my personal opinion. Further
note that I have no involvement with WebExtensions at this time, so I write this
from the point of view of an observer.</p>

<h2>API? What API?</h2>

<p>I shall begin with the proposition that the legacy, non-jetpack
environment for addons is not an API. As ridiculous as some readers might
consider this to be, please humour me for a moment.</p>

<p>Let us go back to the acronym, &ldquo;API.&rdquo; <strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface.
While the usage of the term &ldquo;API&rdquo; seems to have expanded over the years to encompass
just about any type of interface whatsoever, I&rsquo;d like to explore the first letter of that
acronym: <em>Application</em>.</p>

<p>An <em>Application</em> Programming Interface is a specific type of interface that is
exposed for the purposes of building applications. It typically provides a
formal abstraction layer that isolates applications from the implementation
details behind the lower tier(s) in the software stack. In the case of web
browsers, I suggest that there are two distinct types of applications:
web content, and extensions.</p>

<p>There is obviously a very well defined API for web content. On the other hand,
I would argue that Gecko&rsquo;s legacy addon environment is not an API at all! From
the point of view of an extension, there is no abstraction, limited formality,
and not necessarily an intention to be used by applications.</p>

<p>An extension is imported into Firefox with full privileges and can access whatever
it wants. Does it have access to interfaces? Yes, but are those interfaces intended
for <em>applications</em>? Some are, but many are not. The environment that Gecko
currently provides for legacy addons is analagous to an operating system running
every single application in kernel mode. Is that powerful? Absolutely! Is that
the best thing to do for maintainability and robustness? Absolutely not!</p>

<p>Somewhere a line needs to be drawn to demarcate this abstraction layer and
improve Gecko developers&#8217; ability to make improvements under the hood. Last
week&rsquo;s announcement was an invitation to addon developers to help shape that
future. Please participate and please do so constructively!</p>

<h2>WebExtensions are not Chrome Extensions</h2>

<p>When I first heard rumors about WebExtensions in Whistler, my source made it
very clear to me that the WebExtensions initiative is not about making Chrome
extensions run in Firefox. In fact, I am quite disappointed with some of the
press coverage that seems to completely miss this point.</p>

<p>Yes, WebExtensions will be implementing some APIs to be <em>source compatible</em>
with Chrome. That makes it easier to port a Chrome extension, but porting will
still be necessary. I like the Venn Diagram concept that the <a href="https://wiki.mozilla.org/WebExtensions/FAQ">WebExtensions FAQ</a>
uses: Some Chrome APIs will not be available in WebExtensions. On the other hand,
WebExtensions will be providing APIs above and beyond the Chrome API set that
will maintain Firefox&rsquo;s legacy of extensibility.</p>

<p>Please try not to think of this project as Mozilla taking functionality away.
In general I think it is safe to think of this as an opportunity to move that
same functionality to a mechanism that is more formal and abstract.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interesting Win32 APIs]]></title>
    <link href="http://dblohm7.ca/blog/2015/07/28/interesting-win32-apis/"/>
    <updated>2015-07-28T11:30:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2015/07/28/interesting-win32-apis</id>
    <content type="html"><![CDATA[<p>Yesterday I decided to diff the export tables of some core Win32 DLLs to see what&rsquo;s
changed between Windows 8.1 and the Windows 10 technical preview. There weren&rsquo;t
many changes, but the ones that were there are quite exciting IMHO. While
researching these new APIs, I also stumbled across some others that were
added during the Windows 8 timeframe that we should be considering as well.</p>

<h2>Volatile Ranges</h2>

<p>While my diff showed these APIs as new exports for Windows 10, the MSDN docs
claim that these APIs are actually new for the Windows 8.1 Update. Using the
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn781436%28v=vs.85%29.aspx"><code>OfferVirtualMemory</code></a>
and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn781437%28v=vs.85%29.aspx"><code>ReclaimVirtualMemory</code></a>
functions, we can now specify ranges of virtual memory that are safe to
discarded under memory pressure. Later on, should we request that access be
restored to that memory, the kernel will either return that virtual memory to us
unmodified, or advise us that the associated pages have been discarded.</p>

<p>A couple of years ago we had an intern on the Perf Team who was working on
bringing this capability to Linux. I am pleasantly surprised that this is now
offered on Windows.</p>

<h2><code>madvise(MADV_WILLNEED)</code> for Win32</h2>

<p>For the longest time we have been hacking around the absence of a <code>madvise</code>-like
API on Win32. On Linux we will do a <code>madvise(MADV_WILLNEED)</code> on memory-mapped
files when we want the kernel to read ahead. On Win32, we were opening the
backing file and then doing a series of sequential reads through the file to
force the kernel to cache the file data. As of Windows 8, we can now call
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh780543%28v=vs.85%29.aspx"><code>PrefetchVirtualMemory</code></a>
for a similar effect.</p>

<h2>Operation Recorder: An API for SuperFetch</h2>

<p>The <a href="https://msdn.microsoft.com/en-us/library/hh437562%28v=vs.85%29.aspx"><code>OperationStart</code></a>
and <a href="https://msdn.microsoft.com/en-us/library/hh437558%28v=vs.85%29.aspx"><code>OperationEnd</code></a>
APIs are intended to record access patterns during a file I/O operation.
SuperFetch will then create prefetch files for the operation, enabling prefetch
capabilities above and beyond the use case of initial process startup.</p>

<h2>Memory Pressure Notifications</h2>

<p>This API is not actually new, but I couldn&rsquo;t find any invocations of it in the
Mozilla codebase. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366541%28v=vs.85%29.aspx"><code>CreateMemoryResourceNotification</code></a>
allocates a kernel handle that becomes signalled when physical memory is running
low. Gecko already has facilities for handling memory pressure events on other
platforms, so we should probably add this to the Win32 port.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WaitMessage Considered Harmful]]></title>
    <link href="http://dblohm7.ca/blog/2015/03/12/waitmessage-considered-harmful/"/>
    <updated>2015-03-12T15:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2015/03/12/waitmessage-considered-harmful</id>
    <content type="html"><![CDATA[<p>I could apologize for the clickbaity title, but I won&rsquo;t. I have no shame.</p>

<p>Today I want to talk about some code that we imported from Chromium some time
ago. I replaced it in Mozilla&rsquo;s codebase a few months back in <a title="IPC message pump for windows should use WinUtils::WaitForMessage" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1072752">bug 1072752</a>:</p>

<figure class='code'><figcaption><span> (message_pump_win.cc)</span> <a href='http://dblohm7.ca/downloads/code/message_pump_win.cc'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="c1">// A WM_* message is available.</span>
</span><span class='line'>    <span class="c1">// If a parent child relationship exists between windows across threads</span>
</span><span class='line'>    <span class="c1">// then their thread inputs are implicitly attached.</span>
</span><span class='line'>    <span class="c1">// This causes the MsgWaitForMultipleObjectsEx API to return indicating</span>
</span><span class='line'>    <span class="c1">// that messages are ready for processing (Specifically, mouse messages</span>
</span><span class='line'>    <span class="c1">// intended for the child window may appear if the child window has</span>
</span><span class='line'>    <span class="c1">// capture).</span>
</span><span class='line'>    <span class="c1">// The subsequent PeekMessages call may fail to return any messages thus</span>
</span><span class='line'>    <span class="c1">// causing us to enter a tight loop at times.</span>
</span><span class='line'>    <span class="c1">// The WaitMessage call below is a workaround to give the child window</span>
</span><span class='line'>    <span class="c1">// some time to process its input messages.</span>
</span><span class='line'>    <span class="n">MSG</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class='line'>    <span class="n">DWORD</span> <span class="n">queue_status</span> <span class="o">=</span> <span class="n">GetQueueStatus</span><span class="p">(</span><span class="n">QS_MOUSE</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">HIWORD</span><span class="p">(</span><span class="n">queue_status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">QS_MOUSE</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>        <span class="o">!</span><span class="n">PeekMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WM_MOUSEFIRST</span><span class="p">,</span> <span class="n">WM_MOUSELAST</span><span class="p">,</span> <span class="n">PM_NOREMOVE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">WaitMessage</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code is wrong. <strong>Very</strong> wrong.</p>

<p>Let us start with the calls to <code>GetQueueStatus</code> and <code>PeekMessage</code>. Those APIs
mark any messages already in the thread&rsquo;s message queue as having been seen,
such that they are no longer considered &ldquo;new.&rdquo; Even though those function calls
do not remove messages from the queue, any messages that were in the queue at
this point are considered to be &ldquo;old.&rdquo;</p>

<p>The logic in this code snippet is essentially saying, &ldquo;if the queue contains
mouse messages that do not belong to this thread, then they must belong to an
attached thread.&rdquo; The code then calls <code>WaitMessage</code> in an effort to give the
other thread(s) a chance to process their mouse messages. This is where the code
goes off the rails.</p>

<p>The <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644956%28v=vs.85%29.aspx">documentation</a>
for <code>WaitMessage</code> states the following:</p>

<blockquote><p>Note that <code>WaitMessage</code> does not return if there is unread input in the message
queue after the thread has called a function to check the queue. This is
because functions such as <code>PeekMessage</code>, <code>GetMessage</code>, <code>GetQueueStatus</code>,
<code>WaitMessage</code>, <code>MsgWaitForMultipleObjects</code>, and <code>MsgWaitForMultipleObjectsEx</code>
check the queue and then change the state information for the queue so that
the input is no longer considered new. A subsequent call to <code>WaitMessage</code> will
not return until new input of the specified type arrives. The existing unread
input (received prior to the last time the thread checked the queue) is ignored.</p></blockquote>

<p><code>WaitMessage</code> will only return if there is <em>a new</em> (as opposed to <em>any</em>) message
in the queue for the calling thread. Any messages for the calling thread that
were already in there at the time of the <code>GetQueueStatus</code> and <code>PeekMessage</code> calls
are no longer new, so they are ignored.</p>

<p>There might very well be a message at the head of that queue that should be
processed by the current thread. Instead it is ignored while we wait for other
threads. Here is the crux of the problem: we&rsquo;re waiting on other threads whose
input queues are attached to our own! That other thread can&rsquo;t process its
messages because our thread has messages in front of its messages; on the other
hand, our thread has blocked itself!</p>

<p>The only way to break this deadlock is for new messages to be added to the queue.
That is a big reason why we&rsquo;re seeing things like <a title="Page doesn't load/render if the mouse is not moving" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1105386">bug 1105386</a>: Moving the
mouse adds new messages to the queue, making <code>WaitMessage</code> unblock.</p>

<p>I&rsquo;ve already eliminated this code in Mozilla&rsquo;s codebase, but the challenge is
going to be getting rid of this code in third-party binaries that attach their
own windows to Firefox&rsquo;s windows.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Attached Input Queues on Firefox for Windows]]></title>
    <link href="http://dblohm7.ca/blog/2015/03/03/attached-input-queues-on-firefox-for-windows/"/>
    <updated>2015-03-03T17:28:06-07:00</updated>
    <id>http://dblohm7.ca/blog/2015/03/03/attached-input-queues-on-firefox-for-windows</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve <a href="http://dblohm7.ca/blog/2012/11/22/plugin-hang-user-interface-for-firefox/">previously</a> <a href="http://dblohm7.ca/blog/2013/02/15/plugin-hang-ui-on-aurora/">blogged</a>
indirectly about attached input queues, but today I want to address the issue directly. What once was a nuisance in the realm of plugin hangs has grown into a more
serious problem in the land of OMTC and e10s.</p>

<p>As a brief recap for those who are not very familiar with this problem: imagine two windows, each on their own separate threads, forming a parent-child relationship
with each other. When this situation arises, Windows implicitly attaches together and synchronizes their input queues, putting each thread at the mercy of the other
attached threads&#8217; ability to pump messages. If one thread does something bad in its message pump, any other threads that are attached to it are likely to be affected as well.</p>

<p>One of the biggest annoyances when it comes to knowledge about which threads are affected, is that we are essentially flying blind. There is no
way to query Windows for information about attached input queues. This is unfortunate, as it would be really nice to obtain some specific knowledge to allow us to
analyze the state of Firefox threads&#8217; input queues so that we can mitigate the problem.</p>

<p>I had previously been working on a personal side project to make this possible, but in light of recent developments (and a <a href="https://twitter.com/nsIAnswers/status/565883284748795905">tweet from bsmedberg</a>),
I decided to bring this investigation under the umbrella of my full-time job. I&rsquo;m pleased to announce that I&rsquo;ve finished the first cut of a utility that I call
the Input Queue Visualizer, or <code>iqvis</code>.</p>

<p><code>iqvis</code> consists of two components, one of which is a kernel-mode driver. This driver exposes input queue attachment data to user mode. The <code>iqvis</code> user-mode
executable is the client that queries the driver and outputs the results. In the next section I&rsquo;m going to discuss the inner workings of <code>iqvis</code>. Following that, I&rsquo;ll
discuss the <a href="#results">results</a> of running <code>iqvis</code> on an instance of Firefox.</p>

<h2><a name="internals"></a>Input Queue Visualizer Internals</h2>

<p>First of all, let&rsquo;s start off with this caveat: <strong>Nearly everything that this driver does involves undocumented APIs and data structures</strong>. Because of this, <code>iqvis</code>
does some things that you should never do in production software.</p>

<p>One of the big consequences of using undocumented information is that <code>iqvis</code> requires pointers to very specific locations
in kernel memory to accomplish things. These pointers will change every time that Windows is updated. To mitigate this, I kind of cheated: it turns out that
debugging symbols exist for all of the locations that <code>iqvis</code> needs to access! I wrote the <code>iqvis</code> client to invoke the <code>dbghelp</code> engine to extract the pointers that
I need from Windows symbols and send those values as the input to the <code>DeviceIoControl</code> call that triggers the data collection. Passing pointers from user mode to be
accessed in kernel mode is a very dangerous thing to do (and again, I would never do it in production software), but it is damn convenient for <code>iqvis</code>!</p>

<p>Another issue is that these undocumented details change between Windows versions. The initial version of <code>iqvis</code> works on 64-bit Windows 8.1, but different code is required
for other major releases, such as Windows 7. The <code>iqvis</code> driver theoretically will work on Windows 7 but I need to make a few bug fixes for that case.</p>

<p>So, getting those details out of the way, we can address the crux of the problem: we need to query input queue attachment information from <code>win32k.sys</code>, which is the
driver that implements USER and GDI system calls on Windows NT systems.</p>

<p>In particular, the window manager maintains a linked list that describes thread attachment info as a triple that points to the &ldquo;from&rdquo; thread, the &ldquo;to&rdquo; thread, and a count.
The count is necessary because the same two threads may be attached to each other multiple times. The <code>iqvis</code> driver walks this linked list in a thread-safe way to obtain
the attachment data, and then copies it to the output buffer for the <code>DeviceIoControl</code> request.</p>

<p>Since <code>iqvis</code> involves a device driver, and since I have not digitally signed that device driver, one can&rsquo;t just run <code>iqvis</code> and call it a day. This program won&rsquo;t work
unless the computer was either booted with kernel debugging enabled, or it was booted with driver signing temporarily disabled.</p>

<h2><a name="results"></a>Running <code>iqvis</code> against Firefox</h2>

<p>Today I ran <code>iqvis</code> using today&rsquo;s Nightly 39 as well as the lastest release of Flash. I also tried it with Flash Protected Mode both disabled and enabled.
(Note that these examples used an older version of <code>iqvis</code> that outputs thread IDs in hexadecimal. The current version uses decimal for its output.)</p>

<h3>Protected Mode Disabled</h3>

<pre><samp>FromTID ToTID Count
ac8 df4 1
</samp></pre>


<p>Looking up the thread IDs:</p>

<ul>
<li><code>df4</code> is the Firefox main thread;</li>
<li><code>ac8</code> is the plugin-container main thread.</li>
</ul>


<p>I think that the output from this case is pretty much what I was expecting to see. The protected mode case, however, is more interesting.</p>

<h3>Protected Mode Enabled</h3>

<pre><samp>FromTID ToTID Count
f8c dbc 1
794 f8c 3
</samp></pre>


<p>Looking up the thread IDs:</p>

<ul>
<li><code>dbc</code> is the Firefox main thread;</li>
<li><code>f8c</code> is the plugin-container main thread;</li>
<li><code>794</code> is the Flash sandbox main thread.</li>
</ul>


<p>Notice how Flash is attached to plugin-container, which is then attached to Firefox. Notice that transitively the Flash sandbox is effectively attached to Firefox,
confirming previous hypotheses that I&rsquo;ve discussed with colleagues in the past.</p>

<p>Also notice how the Flash sandbox attachment to plugin-container has a count of 3!</p>

<h2>In Conclusion</h2>

<p>In my opinion, my Input Queue Visualizer has already yielded some very interesting data. Hopefully this will help us to troubleshoot our issues in the future. Oh,
and the code is up on <a href="https://github.com/dblohm7/iqvis">GitHub</a>! It&rsquo;s poorly documented at the moment, but just remember to only try running it on 64-bit Windows
8.1 for the time being!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asynchronous Plugin Initialization: Nightly]]></title>
    <link href="http://dblohm7.ca/blog/2014/12/31/asynchronous-plugin-initialization-nightly/"/>
    <updated>2014-12-31T12:00:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2014/12/31/asynchronous-plugin-initialization-nightly</id>
    <content type="html"><![CDATA[<p>As of today&rsquo;s <a href="http://nightly.mozilla.org">Nightly</a>, Asynchronous Plugin
Initialization is available for testing. It is deactivated by default, so in
order to try it out you will need to navigate to <code>about:config</code> and toggle the
<code>dom.ipc.plugins.asyncInit</code> preference to <code>true</code>.</p>

<p>If you experience any problems, please <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Core&amp;component=Plug-ins&amp;blocked=1116806">file a bug</a> that blocks <a title="Let Asynchronous Plugin Initialization ride the train" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1116806">bug 1116806</a>.</p>

<p>Happy New Year!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profile Unlocking in Firefox 34 for Windows]]></title>
    <link href="http://dblohm7.ca/blog/2014/08/21/profile-unlocking-in-firefox-34-for-windows/"/>
    <updated>2014-08-21T10:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2014/08/21/profile-unlocking-in-firefox-34-for-windows</id>
    <content type="html"><![CDATA[<p>Today&rsquo;s <a href="http://nightly.mozilla.org">Nightly 34</a> build includes the work I did
for <a title="Need win32 implementation of nsIProfileUnlocker" href="https://bugzilla.mozilla.org/show_bug.cgi?id=286355">bug 286355</a>: a profile unlocker for our Windows users. This should be very
helpful to those users whose workflow is interrupted by a Firefox instance that
cannot start because a previous Firefox instance has not finished shutting down.</p>

<p>Firefox 34 users running Windows Vista or newer will now be presented with this
dialog box:</p>

<p><a href="http://dblohm7.ca/images/profile-unlocker.png"><img src="http://dblohm7.ca/images/profile-unlocker.png"></a></p>

<p>Clicking &ldquo;Close Firefox&rdquo; will terminate that previous instance and proceed
with starting your new Firefox instance.</p>

<p>Unfortunately this feature is not available to Windows XP users. To support this
feature on Windows XP we would need to call undocumented API functions. I
prefer to avoid calling undocumented APIs when writing production software due
to the potential stability and compatibility issues that can arise from doing
so.</p>

<p>While this feature adds some convenience to an otherwise annoying issue, please
be assured that the Desktop Performance Team will continue to investigate and
fix the root causes of long shutdowns so that a profile unlocker hopefully
becomes unnecessary.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diffusion of Responsibility]]></title>
    <link href="http://dblohm7.ca/blog/2014/08/14/diffusion-of-responsibility/"/>
    <updated>2014-08-14T14:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2014/08/14/diffusion-of-responsibility</id>
    <content type="html"><![CDATA[<p>Something that I&rsquo;ve been noticing on numerous social media and discussion forum
sites is that whenever Firefox comes up, inevitably there are comments in those
threads about Firefox performance. Given my role at Mozilla, these comments are
of particular interest to me.</p>

<p>The reaction to roc&rsquo;s <a href="http://robert.ocallahan.org/2014/08/choose-firefox-now-or-later-you-wont.html">recent blog post</a>
has motivated me enough to respond to a specific subset of comments. These
comments all exhibit a certain pattern: their authors are experiencing problems
with Firefox, they are very dissatisfied, but they are not discussing them in a
way that is actionable by Mozilla.</p>

<h2>How Mozilla Finds Problems</h2>

<p>Mozilla encourages our contributors to run prerelease versions of Firefox,
especially <a href="http://nightly.mozilla.org">Nightly</a> builds. This allows us to do
some good old-fashioned dogfooding during the development of a Firefox release.</p>

<p>We also have many tools that run as part of our continuous integration
infrastructure. Valgrind, Address Sanitizer, Leak Sanitizer, reference count
tracking, deadlock detection, assertions, Talos performance tests, and xperf are
some of the various tools that we apply to our builds. I do not claim that this
list is exhaustive! :-)</p>

<p>We use numerous technologies to discover problems that occur while running on
our users&#8217; computers. We have a crash reporter that (with the user&rsquo;s consent)
reports <a href="https://crash-stats.mozilla.com/home/products/Firefox">data</a> about the
crash. We have Firefox Health Report and <a href="http://telemetry.mozilla.org">Telemetry</a>
that, when consented to, send us useful information for discovering problems.</p>

<p>Our ability to analyze crash report/FHR/telemetry data is limited to those users
who consent to share it with us. As much as I am proud of the fact that we
respect the privacy of our users, this means that we only receive data from a
fraction of them; many users who are experiencing problems are not included in
this data.</p>

<p>Despite the fact that we have all of these wonderful tools to help us deliver
quality releases, the fact is that they cannot exhaustively catch every possible
bug that is encountered out in the wild. There are too many combinations of
extensions and configurations out there to possibly allow us to catch
everything before release.</p>

<p>That&rsquo;s where you, our users, come in!</p>

<h2>If You See Something, Say Something!</h2>

<p>Reddit, Hacker News, Slashdot and other similar sites are fantastic for ranting.
I should know &ndash; I do it with the best of them! Having said that, they are also
terrible for the purposes of bug reporting!</p>

<p>As users it&rsquo;s easy for us to assume that somebody else will encounter our
problems and report them. Unfortunately that is not always the case, especially
with a browser that is as configurable as Firefox.</p>

<h3>Reporting Bugs</h3>

<p>If you are experiencing a bug, the best way to ensure that something can be done
about your bug is to <a href="https://bugzilla.mozilla.org/enter_bug.cgi?format=guided">report it</a>
in Bugzilla. This might seem a little bit intimidating for somebody who is new
to bug reporting, but I assure you, Mozillians are really nice! As long as you
follow the <a href="https://bugzilla.mozilla.org/page.cgi?id=etiquette.html">etiquette guidelines</a>,
you&rsquo;ll be fine! One suggestion though: try to follow our
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/QA/Bug_writing_guidelines">bug writing guidelines</a>.
Doing so will maximize the likelihood of a contributor being able to reproduce
your problem. In addition to these suggestions for bug filing, I also suggest
including certain types of data for specific types of problems:</p>

<h3>Reporting a Bug for High Memory Usage</h3>

<p>If you&rsquo;re experiencing problems with Firefox&rsquo;s memory use, open a tab, and
point your browser to <code>about:memory</code>. This nifty feature provides a breakdown
of Firefox memory consumption. Save that report and attach it to the bug that
you&rsquo;ve filed.</p>

<h3>Reporting a Bug for Slowness or Heavy CPU Usage</h3>

<p>If you want report a problem with Firefox being slow and/or mysteriously
consuming large amounts of CPU time, the best way to help us is
is to include data that has been generated by the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler">Gecko Profiler</a>.
[<em>This data is referred to as a &ldquo;profile,&rdquo; but please do not confuse it with the
user profile that stores your settings and browser history &ndash; they are different
things with the same name.</em>] This tool tracks how Firefox uses your CPU over
time. If you are able to attach a profile that was taken during a period of time
where Firefox was running poorly, it will help us understand what exactly Firefox
was doing. Unfortunately this is tool requires a bit of technical savvy, but
attaching the URL of an uploaded profile to your performance bug can be very helpful.</p>

<h3>Reporting a Bug for a Persistent, Reproducable Crash</h3>

<p>As you can see in our <a href="https://crash-stats.mozilla.com/home/products/Firefox">crash report data</a>,
crashes reported to Mozilla are ranked by frequency. As you might expect, this
implies that it&rsquo;s often the squeaky wheels that get the grease.</p>

<p>If you have an easily reproducable crash and you are sending your reports to
Mozilla, you can help us by pointing Firefox to <code>about:crashes</code>. This page lists
all of the crash reports that have been generated on your computer. If the crash
that you are experiencing isn&rsquo;t on our list of top crashers, you can still help
us to fix it: filing a bug that includes multiple crash report URLs from your
<code>about:crashes</code> screen will help tremendously.</p>

<h3>Reporting a Bug for a Website that Looks Wrong in Firefox</h3>

<p>I&rsquo;d suggest reporting your problem over at <a href="http://webcompat.com">webcompat.com</a>.
Volunteers will review your report and determine whether your problem is caused
by the website or by Firefox, and file a bug with the appropriate entity.</p>

<h3>I have a problem that isn&rsquo;t listed here. What should I do?</h3>

<p>Send us <a href="https://input.mozilla.org/en-US/feedback">feedback</a>!</p>

<h2>In Conclusion</h2>

<p>If there is one idea that you can take away from this post (a TL;DR, if you will),
it is this: <em>Mozilla cannot fix 100% of the bugs that we do not know about.</em></p>

<p>Taking an active role in the Mozilla community by reporting your issues through
the proper channels is the best way to ensure that your problems can be fixed.</p>

<p><strong>EDIT:</strong> To be clear: What I am suggesting is that users who are enthusiastic
enough to post a comment to Hacker News (for example) should also be savvy
enough to be able to file a proper bug report. Please do not misconstrue this
post as a demand that novice users start filing bugs.</p>

<p><strong>EDIT August 15, 2014:</strong> Nick Nethercote just <a href="https://blog.mozilla.org/nnethercote/2014/08/15/the-story-of-a-tricky-bug/">blogged</a>
about a tricky memory bug that couldn&rsquo;t have been diagnosed without the help of
a Redditor whose complaint we steered to Bugzilla.</p>

<p><strong>EDIT August 23, 2014:</strong> Wow, this has blown up. More edits to update this post
with additional information in repose to some of the questions posted in the
comments. Thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asynchronous Plugin Initialization: An Introduction]]></title>
    <link href="http://dblohm7.ca/blog/2014/06/17/asynchronous-plugin-initialization-an-introduction/"/>
    <updated>2014-06-17T02:30:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2014/06/17/asynchronous-plugin-initialization-an-introduction</id>
    <content type="html"><![CDATA[<p>I have spent a lot of time this quarter working on <a title="Asynchronous Initialization of Out-of-process Plugins" href="https://bugzilla.mozilla.org/show_bug.cgi?id=998863">bug 998863</a>, &ldquo;Asynchronous
Initialization of Out-of-process Plugins.&rdquo; While the bug summary is fairly self
explanatory, I would like to provide some more details about why I am doing this
and what kind of work it entails. I would also like to wrap up the post with an
early demonstration of this feature and present some profiles to illustrate the
potential performance improvement.</p>

<h2>Rationale</h2>

<p>The reason that I am undertaking this project is because NPAPI plugin startup
is our most frequent cause of jank. In fact, at the time of this writing, our
<a href="http://telemetry.mozilla.org/chromehangs/">Chrome Hangs telemetry</a> is showing
that 4 out of our top 10 most frequent offending call stacks are related to
plugin initialization and instantiation. Furthermore, creating the
plugin-container.exe child process is the #1 most frequent chrome hang offender
(Note that our Chrome Hang telemetry consists entirely of Windows builds, where
process creation is quite expensive).</p>

<h2>A High-level Breakdown of NPAPI Initialization and Instantiation</h2>

<p>The typical steps involved can be broken down as follows:</p>

<ol>
<li>Launch the <code>plugin-container</code> process;</li>
<li>Call <code>NP_Initialize</code> to load the plugin;</li>
<li>Create instances by calling <code>NPP_New</code>;</li>
<li>Call <code>NPP_NewStream</code> for instances that load stream data;</li>
<li>If an instance is scriptable, call <code>NPP_GetValue</code> to obtain information
about the plugin&rsquo;s scriptable object.</li>
</ol>


<p>The patch that I am working on modifies steps 1 through 4 to run asynchronously.
Step 5 is a special case &ndash; we asynchronously return a proxy object, but if a
synchronous JS method is called on that object, we must wait for the plugin to
initialize (if it has not yet done so). My hope is that if we have to call a
synchronous JS method on the proxy object, plugin initialization will be far
enough along that the wait will be minimal.</p>

<h2>A Brief Demonstration</h2>

<p>The following video compares two locally-built Nightlies that are identical
except for the asynchronous initialization patch. After loading the browser
with a page containing several embedded Flash objects, we can profile and
observe the effects of this patch.</p>

<iframe width="420" height="315" src="//www.youtube-nocookie.com/embed/HZ8Z2Drv8uI?rel-0" frameborder="0" allowfullscreen></iframe>


<p>Here are links to some profiles:</p>

<p><a href="http://people.mozilla.org/~bgirard/cleopatra/#report=a5a96119742fa75b64ab7d12566eede68468ef3c">Synchronous Plugin Initialization</a></p>

<p><a href="http://people.mozilla.org/~bgirard/cleopatra/#report=282e372d3357316307c182607f26c00f4f41011e">Asynchronous Plugin Initialization</a></p>

<h2>Disclaimer</h2>

<p>This patch requires some further work on scripting and stabilization. The
information in this post is subject to change. :-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Detecting Main Thread I/O With SPS]]></title>
    <link href="http://dblohm7.ca/blog/2013/06/12/detecting-main-thread-i-slash-o-with-sps/"/>
    <updated>2013-06-12T18:00:00-06:00</updated>
    <id>http://dblohm7.ca/blog/2013/06/12/detecting-main-thread-i-slash-o-with-sps</id>
    <content type="html"><![CDATA[<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=867762">bug 867762</a> I am landing I/O
interpose facilities for SPS. This feature will allow main thread I/O to be
displayed in the profiler UI.</p>

<p>There are a few components to this patch. Classes that implement the
<code>IOInterposerModule</code> interface are responsible for hooking into an arbitrary I/O
facility and calling into <code>IOInterposer</code> with those events.</p>

<p>The <code>IOInterposer</code> receives those events and then dispatches them to any registered
observers. For the purposes of SPS there is only one observer,
<code>ProfilerIOInterposeObserver</code>, however I wrote this keeping in mind that we
may eventually want to use the I/O interpose facilities for other purposes (such
as shutdown write poisioning).</p>

<p>For bug 867762 I have implemented two modules. <code>NSPRInterposer</code> hooks into NSPR
file I/O and generates events whenever a <code>PR_Read</code>, <code>PR_Write</code>, or <code>PR_Sync</code> occurs.
The second module, <code>SQLiteInterposer</code>, leverages the SQLite VFS that we use for
telemetry to tap into reads, writes, and fsyncs generated by SQLite. In the future
we expect to expand this into several additional modules. Some ideas include a module
that uses Event Tracing for Windows to read events from the Windows kernel and a
module that interposes calls to <code>read</code>, <code>write</code>, and <code>fsync</code> on Linux.</p>

<p>On the observer side of things, for now we simply insert a marker into the profiler
timeline whenever main thread I/O is reported. Here is a sample screenshot of the
markers in action (the pink stuff for readers who are unfamiliar with SPS markers):</p>

<p><a href="http://dblohm7.ca/images/iomarkers.png"><img src="http://dblohm7.ca/images/iomarkers.png"></a></p>

<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=867757">bug 867757</a> (under review)
this will become more sophisticated, as SPS will immediately sample the callstack of
the thread whose I/O has been intercepted. This annotated stack will be inserted
directly into the timeline.</p>

<p>There will need to be some UI changes for this to be presented in a reasonable way,
but with both existing patches applied the data is already useful. By firing up
Cleopatra and filtering on either <code>NSPRInterposer</code> or <code>SQLiteInterposer</code>, you can
isolate and view the main thread I/O stacks:</p>

<p><a href="http://dblohm7.ca/images/iofilteredstacks.png"><img src="http://dblohm7.ca/images/iofilteredstacks.png"></a></p>

<p>Hopefully these patches will prove to be beneficial to our efforts to eliminate
main thread I/O.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plugin Hang UI on Aurora]]></title>
    <link href="http://dblohm7.ca/blog/2013/02/15/plugin-hang-ui-on-aurora/"/>
    <updated>2013-02-15T17:00:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2013/02/15/plugin-hang-ui-on-aurora</id>
    <content type="html"><![CDATA[<h2>The UI Has Landed</h2>

<p>The <a href="http://dblohm7.ca/blog/2012/11/22/plugin-hang-user-interface-for-firefox/">Plugin Hang UI</a>
landed in mozilla-central in time for January&rsquo;s merge. This means that it is
now available on both Nightly and Aurora.</p>

<p>While it&rsquo;s great that this code is now available to a larger audience, there
are consequences to this. :-)</p>

<h2>Telemetry and Pref Adjustments</h2>

<p>The first (and more pleasant) consequence is that we are now receiving telemetry
about the UI&rsquo;s usage patterns. This allows us to make some adjustments as the
Plugin Hang UI gets closer to the release channel. As happy as I am that this
feature will be putting users in the driver&rsquo;s seat when dealing with hung
plugins, it&rsquo;s also important to not annoy users.</p>

<p>Initially our telemetry suggested that the Plugin Hang UI frequently appeared
but then cancelled automatically because the plugin resumed execution. This
indicated to us that we should increase the default value of the
<code>dom.ipc.plugins.hangUITimeoutSecs</code> preference (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=833560">bug 833560</a>).
There has also been some discussion about scaling the Hang UI threshold depending
on hardware performance and user behaviour. This threshold is tricky to balance;
while we want users to be able to terminate a hanging plugin, we want to provide
that feature with minimal annoyance.</p>

<h2>Crashes</h2>

<p>Another consequence of the feature landing is that we received reports from
Nightly and Aurora showing that the Plugin Hang UI was inducing crashes in the
browser itself. Unfortunately the only thing that the stack traces were telling
us was that the browser-side code that hosts out-of-process plugins was not
being cleaned up properly after forcibly terminating the plugin container. We
didn&rsquo;t have any steps to reproduce. What broke this mystery wide open was when
our crash stats were finally able to show some correlations. I learned that
nearly 50% of the crashes happened on single-core CPUs.</p>

<h3>The Problem</h3>

<p>Once I was able to test this out for myself, the issue revealed itself in short order.
Fortunately for me, even though the problem involved thread scheduling, I was still able
to reproduce it in a debugger. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=828034#c8">This patch</a>
took care of the problem.</p>

<p>There&rsquo;s a bit of nuance to what was happening with this crash. When
<code>plugin-container.exe</code> is forcibly terminated, cleanup of the browser-facing
plugin code may be executed in one of two different sequences:</p>

<h3>Sequence 1 (Most common)</h3>

<ol>
<li><p>After terminating <code>plugin-container.exe</code>, the Plugin Hang UI posts a
<code>CleanupFromTimeout</code> work item to the main thread. Concurrently on the
I/O thread, Firefox&rsquo;s <code>RPCChannel</code> detects an error and posts a
<code>OnNotifyMaybeChannelError</code> work item.</p></li>
<li><p><code>OnNotifyMaybeChannelError</code> executes and sets the channel&rsquo;s state to
<code>ChannelError</code>. It also cleans up the <code>PluginModuleParent</code> actor and its
actors for subprotocols.</p></li>
<li><p><code>CleanupFromTimeout</code> runs and attempts to Close the channel. This
is effectively a no-op since the channel was already closed with an
error status by step 2.</p></li>
</ol>


<h3>Sequence 2 (Less common unless running on fewer cores)</h3>

<ol>
<li><p>Same as in Sequence 1.</p></li>
<li><p><code>CleanupFromTimeout</code> runs before <code>OnNotifyMaybeChannelError</code>. This
work item attempts to do a regular <code>Close</code> on the channel. Since the
channel&rsquo;s state is still set to <code>ChannelConnected</code>, the close operation
doesn&rsquo;t realize that it needs to do additonal cleanup. It performs
a clean shutdown of the RPC channel without properly cleaning up the
IPDL actors.</p></li>
<li><p><code>OnMaybeNotifyChannelError</code> runs, sees the channel is already closed
due to the activities in step 2, and does nothing.</p></li>
<li><p>A crash later occurs because the actors were never cleaned up properly.</p></li>
</ol>


<h3>Some Additional Analysis</h3>

<p>Sequence 2 cannot crash if the <code>plugin-container.exe</code> process is terminated
by the main thread. This is because <code>PluginModuleParent::ShouldContinueFromReplyTimeout</code>
returns <code>false</code> in this case and the channel&rsquo;s state is set to <code>ChannelTimeout</code> by
the time that the <code>CleanupFromTimeout</code> work item executes. This guarantees that
a full cleanup will be done by <code>CleanupFromTimeout</code>.</p>

<p>With the Plugin Hang UI, <code>plugin-container.exe</code> is not terminated by the main
thread, so the channel&rsquo;s state must be explicitly updated after termination.</p>

<h3>Solution</h3>

<p>The patch modifies the <code>CleanupFromTimeout</code> work item so that if the
plugin container was terminated outside the main thread, the channel is
explicitly closed with an error state. This ensures that the actors are
properly cleaned up.</p>

<h2>Hangs</h2>

<p>I filed <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=834127">bug 834127</a>
when QA discovered that sometimes the Plugin Hang UI was not being displayed.
I found out that Firefox was correctly spawning <code>plugin-hang-ui.exe</code>, however
it was not showing any UI.</p>

<p>This lead be back down the input queue rabbit hole that I briefly discussed
last time. I learned that on an intermittent basis, the Plugin Hang UI dialog
box was being hung up on Win32 <code>ShowWindow</code> and <code>SetFocus</code> calls. What I did
know was that my attempts to explicitly detach the Plugin Hang UI&rsquo;s thread
from the hung Firefox thread weren&rsquo;t working as well as I would have liked.</p>

<p>After <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=834127#c9">numerous attempts</a>
at fixing these issues, I determined that for the time being we will need to
rescind the owner-owned relationship between Firefox and the Plugin Hang UI
dialog. If we didn&rsquo;t do so, seemingly benign actions like calling <code>PeekMessage</code>
or passing a <code>WM_NCLBUTTONDOWN</code> message to <code>DefWindowProc</code> would be enough
to bring the Plugin Hang UI to a halt. Why is this, you ask? I decided to
peek into kernel mode to find out.</p>

<h3>Adventures in Kernel Mode</h3>

<p>Recall that the guts of <code>USER32</code> and <code>GDI32</code> were moved into kernel mode
via <code>win32k.sys</code> in the Windows NT 3.5 timeframe. It follows that any
efforts to examine Win32 internals necessitates peering into kernel mode.
I didn&rsquo;t need an elaborate remote debugging setup for my purposes, so I
used <a href="http://technet.microsoft.com/en-us/sysinternals/bb897415">Sysinternals LiveKd</a>
to take a snapshot of my kernel and debug it.</p>

<p>My workflow was essentially as follows:</p>

<ol>
<li>Plugin Hang UI gets stuck</li>
<li>Attach a debugger (I use WinDbg) to <code>plugin-hang-ui.exe</code></li>
<li>Run LiveKd</li>
<li>Type <code>!thread -t &lt;tid&gt;</code> into the kernel debugger, where <code>&lt;tid&gt;</code> is the
thread ID that is hung in the user-mode WinDbg</li>
</ol>


<p>Every kernel-mode call stack that I examined on a hung thread usually ended up going through this code path:</p>

<pre><samp>
...
Child-SP          RetAddr           : Args to Child                                                           : Call Site
fffff880`0def3ec0 fffff800`0327c652 : fffffa80`079c43c0 fffffa80`079c43c0 00000000`00000000 fffffa80`00000008 : nt!KiSwapContext+0x7a
fffff880`0def4000 fffff800`0328da9f : fffffd54`0000000c fffffd54`000002a0 000002ac`00000000 00000804`fffffd54 : nt!KiCommitThreadWait+0x1d2
fffff880`0def4090 fffff800`03278a14 : 00000000`00000000 00000000`00000005 00000000`00000000 fffff800`03279600 : nt!KeWaitForSingleObject+0x19f
fffff880`0def4130 fffff800`03279691 : fffffa80`079c43c0 fffffa80`079c4410 00000000`00000000 00000000`00000000 : nt!KiSuspendThread+0x54
fffff880`0def4170 fffff800`0327c85d : fffffa80`079c43c0 00000000`00000000 fffff800`032789c0 00000000`00000000 : nt!KiDeliverApc+0x201
fffff880`0def41f0 fffff800`0328da9f : fffffa80`0a7510e0 fffff800`0327c26f fffffa80`00000000 fffff800`03402e80 : nt!KiCommitThreadWait+0x3dd
fffff880`0def4280 fffff960`0010d457 : fffff900`c2255200 00000000`0000000d 00000000`00000001 00000000`00000000 : nt!KeWaitForSingleObject+0x19f
fffff880`0def4320 fffff960`0010d4f1 : fffff880`0def0000 fffff900`c08e0e20 00000000`00000000 00000000`00000000 : win32k!xxxRealSleepThread+0x257
fffff880`0def43c0 fffff960`000c46d3 : 00000000`00000000 fffff900`c093ee90 00000000`00000200 00000000`00000046 : win32k!xxxSleepThread+0x59
fffff880`0def43f0 fffff960`0010c53e : fffff900`c093ee90 fffff900`c08e0e20 00000000`00000000 fffff900`c25724b0 : win32k!xxxInterSendMsgEx+0x112a
fffff880`0def4500 fffff960`000d8ccf : fffff900`c25724b0 fffff900`c25724b0 <mark>00000000`003c031a</mark> fffff900`c0800b90 : win32k!xxxSendMessageTimeout+0x1de
fffff880`0def45b0 fffff960`000dae0b : fffff960`00000006 fffff880`0def47c0 fffff960`00000000 fffff900`00000000 : win32k!xxxCalcValidRects+0x1a3
fffff880`0def46f0 fffff960`000dac3a : fffff900`00000001 fffff900`c08e0e20 fffff880`0def49b8 fffff900`00000000 : win32k!xxxEndDeferWindowPosEx+0x18f
fffff880`0def47b0 fffff960`000d6e09 : 00000000`00000000 00000000`00000001 fffff900`00000000 fffff800`00000000 : win32k!xxxSetWindowPos+0x156
fffff880`0def4830 fffff960`0007c66d : fffff900`00000000 fffff900`0004366c fffff900`00000000 fffff900`c209f410 : win32k!xxxActivateThisWindow+0x441
...
</samp></pre>


<p>The highlighted hexadecimal value above is a handle to a window with class
<code>MSCTFIME UI</code> (i.e. a Microsoft IME window) that was created by the main
UI thread in the hung Flash process. Despite my best efforts to try to
disconnect the Plugin Hang UI input queue from these threads, Windows is
insistent on sending a synchronous, inter-thread message to the IME window
on the hung Flash thread. This doesn&rsquo;t happen if we omit setting Firefox&rsquo;s
<code>HWND</code> as the Plugin Hang UI&rsquo;s owner window.</p>

<h3>Implications</h3>

<p>Now that the Plugin Hang UI specifies a <code>NULL</code> owner, Windows can no longer
guarantee that the Plugin Hang UI will always appear above the Firefox window
that was active at the time that the plugin hang occurred. Having said that,
our experiments have shown that Windows does not try to promote an unresponsive
window to the front of the Z-order.</p>

<p>In a multiple-window situation, Windows may move the other, inactive Firefox
windows ahead of the Plugin Hang UI in the Z-order, but the window that was
active when Firefox first hung does not move. I think that this is acceptable.
In fact, the same behavour would be observable if we had been able to specify
an owner.</p>

<p>If you&rsquo;re interested in helping to test this feature, please install Nightly
and try the repro from <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=834127#c0">bug 834127</a>.
When the Plugin Hang UI fires, try to move around the Plugin Hang UI as well
as the other windows on your desktop, including Firefox. If the Z-order changes
differently from the way that I have observed here, please try to generate
some steps to reproduce, drop me a line (aklotz on <code>#perf</code> or MoCo email)
and let me know what&rsquo;s going on. Thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plugin Hang User Interface for Firefox]]></title>
    <link href="http://dblohm7.ca/blog/2012/11/22/plugin-hang-user-interface-for-firefox/"/>
    <updated>2012-11-22T10:22:00-07:00</updated>
    <id>http://dblohm7.ca/blog/2012/11/22/plugin-hang-user-interface-for-firefox</id>
    <content type="html"><![CDATA[<p>My first significant project at Mozilla has been
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=805591">bug 805591</a>,
implementing a user interface to be displayed by Firefox when
an out-of-process plugin hangs. This is important because when NPAPI
plugins hang, they block the main thread in Firefox. When the main
thread is blocked, the Firefox user interface grinds to a halt.</p>

<p>The purpose of the Plugin Hang UI is twofold:</p>

<ul>
<li>To inform the user which plugin is responsible for the hang; and</li>
<li>Provide the user with an opportunity to terminate the plugin if he/she wishes.</li>
</ul>


<p>Currently this is feature is exclusive to Firefox Desktop on Windows.
When the Hang UI is invoked, you&rsquo;ll notice that Firefox has created
a new child process, plugin-hang-ui.exe. This child process will
display the Plugin Hang UI dialog box.</p>

<p><img src="http://dblohm7.ca/images/hangui.png"></p>

<p>My patch is currently under review, but the Plugin Hang UI is fully functional
in a <a href="http://ftp.mozilla.org/pub/mozilla.org/firefox/try-builds/aklotz@mozilla.com-f5d8fdf4f29a/try-win32/firefox-19.0a1.en-US.win32.installer.exe">try build</a>,
so please check it out and play with it!</p>

<h2>Changes to Preferences</h2>

<ul>
<li><p><code>dom.ipc.plugins.hangUITimeoutSecs</code>: This is the number of seconds
that Firefox waits for a hung plugin before displaying the Plugin Hang UI.
Setting this value to zero disables the Plugin Hang UI.</p></li>
<li><p><code>dom.ipc.plugins.timeoutSecs</code>: This pref is still used with the Hang UI,
but its semantics change a little bit. Once the Plugin Hang UI has been
displayed, Firefox will wait <code>dom.ipc.plugins.timeoutSecs</code> seconds before
terminating the plugin automatically, even if the user did not elect to
stop the plugin using the Hang UI. This is nearly identical to the way that
Firefox behaves without the Hang UI &ndash; the only difference is that now this
timeout period doesn&rsquo;t commence until the Hang UI is displayed.</p></li>
<li><p><code>dom.ipc.plugins.hangUIMinDisplaySecs</code>: This is the minimum number
of seconds that Firefox should display the Plugin Hang UI. If
<code>dom.ipc.plugins.timeoutSecs</code> is set to a value lower than this
pref, the Hang UI is disabled. The idea here is that, if
<code>dom.ipc.plugins.timeoutSecs</code> is only set to 5 seconds to begin with,
then the plugin will already have been auto terminated before the
user has half a chance to read the Plugin Hang UI.</p></li>
</ul>


<h2>Implementation Details</h2>

<p>There are a couple of interesting things that I&rsquo;d like to point out
relating to this patch.</p>

<p>Because the Plugin Hang UI is a child process, I needed to ensure that
its window always appears in front of the hung Firefox window. I decided
that I would have Firefox send its top-level <code>HWND</code> over to the child
process so that the Hang UI could specify that handle as the owner of its
top-level window. If you&rsquo;ve seen <a href="http://blogs.msdn.com/b/oldnewthing">Raymond Chen&rsquo;s</a>
<a href="http://channel9.msdn.com/Blogs/scobleizer/Raymond-Chen-PDC-05-Talk-Five-Things-Every-Win32-Programmer-Needs-to-Know">Five Things Every Win32 Programmer Needs to Know</a>,
then you&rsquo;ll know what is coming: Deadlock!</p>

<p>The problem is that the Hang UI window and the Firefox window are
created by different threads. When I set the owner relationship
between the Hang UI top-level window and the Firefox top-level window,
the window manager implicitly synchronizes both threads&#8217; input queues.
In the case of the Plugin Hang UI, this is a huge problem: Windows just
synchronized the Hang UI&rsquo;s input queue with a hung thread!</p>

<p>What&rsquo;s the solution, then? Think about it this way: the window manager
might have implicitly synchronized the two threads&#8217; input queues, but
there&rsquo;s no reason why we can&rsquo;t then <em>explicitly</em> desynchronize them!</p>

<p>Here&rsquo;s the first thing I do in the Plugin Hang UI&rsquo;s <code>WM_INITDIALOG</code> handler:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>      <span class="c1">// Disentangle our input queue from the hung Firefox process</span>
</span><span class='line'>      <span class="n">AttachThreadInput</span><span class="p">(</span><span class="n">GetCurrentThreadId</span><span class="p">(),</span>
</span><span class='line'>                        <span class="n">GetWindowThreadProcessId</span><span class="p">(</span><span class="n">mParentWindow</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">),</span>
</span><span class='line'>                        <span class="n">FALSE</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Without this line, the Hang UI is at risk of deadlock. This is
especially true if the user attempts to send input to the Firefox
window underneath.</p>
]]></content>
  </entry>
  
</feed>
